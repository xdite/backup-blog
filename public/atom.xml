<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blog.XDite.net]]></title>
  <link href="http://blog.xdite.net/atom.xml" rel="self"/>
  <link href="http://blog.xdite.net/"/>
  <updated>2012-10-24T09:49:32+08:00</updated>
  <id>http://blog.xdite.net/</id>
  <author>
    <name><![CDATA[xdite]]></name>
    <email><![CDATA[xdite@about.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[給尚未大學畢業的朋友的幾個人生建議 - 能力培養篇]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/23/some-advice-for-undergraduate/"/>
    <updated>2012-10-23T21:10:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/23/some-advice-for-undergraduate</id>
    <content type="html"><![CDATA[<p>前天，應母校 <a href="http://www.sam.pccu.edu.tw">文化大學應用數學系</a> 的邀請，再次回系演講關於大學後的職涯規劃。這已經是第二次受邀演講相同的主題。受邀的原因相當單純。純粹是我的表現一再的讓系上老師跌破眼鏡，在短短數年間一路從不起眼的小職員，迅速累積出社會普世價值觀上相對可觀的成就。( T客邦技術部經理、HTC 資深經理、Facebook World Hack Grand Prize…etc.) 所以老師們想邀請我回校演講。分享我在這一路上成長的感想，並給予學弟妹人生建議，回答對於對於將來路上的一些疑惑。</p>

<p>會後的問題，我一路上其實在各大場合都答過類似的問題。內心對於大學生缺乏適當明燈指引，相當感慨。有些問題我想甚至可能只有我這樣的經歷的人，才可能答的出來。這些建議我覺得若只限於在校學弟妹才能聽到，相當可惜。所以趁記憶猶新，把它整理出來。</p>

<p>當然，這只是基於我的人生經歷，做出來的建議。並非絕對，還請讀者自行判斷斟酌。</p>

<h3>最值得投資的技能</h3>

<h4>1. 中文速讀</h4>

<p>我最常被問到的問題其中有一個是：「你覺得出社會前你練過最值得的技能是什麼？」對於這個問題，我的答案毫不猶豫的會是「中文速讀」。</p>

<p>為什麼是「中文速讀」？坦白說，在小時候會選擇投資這個技能，原因純粹是 (1) 被逼 (2) 我有天份 (3) 可以在短時間看完一堆雜文小說很爽。</p>

<p>18 歲前，「速讀」這個技能對我來說，是可有可無的雞肋。但是在 18 歲以後，遇上網際網路的高速成長，整個世界呈現一個「資訊爆炸」的狀態。原先的雞肋技能，搖身一變成為我一路上闖蕩的最厲害武器。</p>

<p>原本我個人學習的速度，還被大大牽制在老家附近的書店販售書種的數量。因為網際網路的爆炸性成長，我的閱讀視野一下子被拉到網際網路的邊界。而高速的閱讀速度，即便在資訊爆炸的今天，我還是能夠只花上極少時間，就能夠輕鬆追完今日關注 timeline 上的大小事…</p>

<p>工作上遇到任何疑難雜症，也能透過閱讀速度以及網際網路，快速的整理出相對應的解決方案。</p>

<p>如果時間只能投資在一個專業技能上，我毫不猶豫會推薦你選擇「中文速讀」。</p>

<h4>2. 英文能力</h4>

<p>其次，我推薦練習的技能就是「英文能力」。每當學弟妹聽到我這樣說，無不哀號遍野，瞬間卻步。</p>

<p>其實，學弟妹不知道的是：所謂的「英文能力」真的非常非常重要。重要到超乎你想像。我出社會到現在的感想是，「英文能力」的重要性也遠超乎我當年的想像。</p>

<p>不只是所謂好的工作需要英文（外商工作需要聽說讀寫）。甚至是幫助你高速成長，超車過同儕的專業知識也通通都是英文 (如同我現在賴以為生的專業技能： Ruby on Rails )。就別說這麼專業的進階知識好了。</p>

<p>就連外國的許多線上初階自助學習課程：<a href="http://codeschool.com">CodeSchool</a>、<a href="http://www.codecademy.com/">Codecademy</a>。也都是英文教材。</p>

<p>其實台灣不乏素質高的軟體人才、學生。其實只要正確的導引，具備適當的教材與練習，成果往往能突破目前國民教育造成的限制。唯一可惜的是，大家往往只要聽到「是英文的」，下意識就刪掉這個選項。我一直覺得這是一件可惜的事。</p>

<p>很多學弟妹也許會期待，將來這些東西有天會有好心人出中文版。就我的觀察，這個機會可能是越來越小。目前的現實是：這個世界呈現高速成長中，能夠翻譯這些知識的人，往往也是能夠少數能夠突破天際線以及國際限制的人。他們目前的聚焦，無不是專注在自身能力與事業的突破。很少能夠還有資源和時間能夠停下來拉別人…</p>

<p>於是造成了一個極端的現象：強者越強，弱者越弱。甚至就算強者有心停下來救別人，有時候往往也不知道怎救起&#8230;</p>

<p>大家對於「英文學習」的盲點，在於英文學習很枯燥，無法靜下心來投資一個「不知道有什麼報酬率」的知識。</p>

<p>其實各位可能不知道的是：在大學之前，我的英文能力也非常非常的弱，每次段考都只有 30 分。但是我現在的英文能力，卻能讀聽能說能寫（哈，抱歉，有時候 blog 還是一堆 typo 錯字）。跟外國人順暢的聊天和工作的能力我應該還算是不錯的。</p>

<p>如今我具備的所有專業知識與能力，甚至是得到的機運，也全部都是因為英文賺進來的。</p>

<p>現在回頭看，英文練得起來的原因，只是因為我的一個單純的小嗜好：「看美劇」。其實把英文練好並沒有那麼難。我雖然不喜歡「嚴肅的學英文」，但卻非常喜歡看美劇（含字幕）。劇情精彩是我當初被深深吸引的一個原因，十年來我看過不下千集美劇。</p>

<p>習慣美國人講話的速度，是我進步的第一環。習慣了聽美國人講話，自然腔調與口語速度就會自然而然接近美國人。聽說能力就自然起來了。</p>

<p>因為不害怕英文，在需要大量接觸英文的程式開發專業環境下，就會完全不覺得英文是什麼可怕的門檻。很快的，自己就會習慣「太平洋其實並沒有加蓋」這件事。</p>

<p>能夠接觸到的機會，看到的世界，就不會被所謂的「台灣洗腦電視台」蓋台進入無窮迴圈。（其實我已經接近十年沒有在看台灣新聞與連續劇了…）</p>

<p>我認知到的一件現實是，現在全球已經進入非常扁平化而且快速變革的激烈變化中。如果國家國力本身夠強，還抵的住這種變化的衝擊。但是台灣，在經過這四年政府無作為且大量惡搞的狀況下，本地機會迅速的惡劣、變小、變少。</p>

<p>如果不能夠把自己變成全球需要的人才，將很快的被這波洪流吞噬。如果你的英文能力不好，勢必只能是被吞沒的那一群人…</p>

<h4>3. 寫作能力與程式開發能力</h4>

<p>其三，我認為值得投資的部分是：「寫作能力」或者是「程式開發能力」。</p>

<p>每當我一提到這兩件事，也是很多人馬上會皺起眉頭。</p>

<p>但我一路上走來的感想是：我很高興能夠同時都把這兩塊能力練得不錯。而且是這兩個能力，才把我帶到今天這條路上。</p>

<p>（也許你認為我能夠拿到 Grand Prize of Facebook World Hack，是個程式奇才，其實我可以很清楚的跟你說：我明白自己不是寫程式的料。</p>

<p>我真正有狂熱興趣的是寫作以及作產品。我小學立志當作家或歷史學家。成為一個厲害的 Developer 從來不在我念大學之前的志願選項。</p>

<p>我只是喜歡作網站，我被迫去學 coding，去學有關 coding 的 everything，然後莫名其妙的就被迫站在這個領域的前端…
）</p>

<p>寫作能力與程式開發能力，帶給我的影響是：</p>

<ol>
<li><p>寫作能極大化的強迫把我沒有章法的思緒收斂在一起，當累積到能夠把想法準確的寫下來，並重複的寫到讓人家明白。最大的受益人其實是我自己，我透過寫作梳理以及掌握了整件事的來龍去脈。能夠把事情精準的重複，才是弄懂整件事。透過不斷的寫作可以大大強化「把事情想清楚」這方面的能力。</p></li>
<li><p>程式開發也是類似的事。Knuth 曾經說過 「A person does not really understand something until after teaching it to a computer」。電腦並沒有很聰明，它只能執行絕對有邏輯的事情。換句話說：你在教電腦事情的時候，其實是在釐清自己的思考與整件事的邏輯。沒有邏輯的事，你又如何期待可以被 work 呢？</p></li>
</ol>


<p>而培養寫作能力與程式開發能力，其實最大的好處不是培養出強大的邏輯核心能力群。而是產生出來的副產品：「文章」以及「程式碼」。</p>

<p>很多 Developer 常常怨歎，我也很有能力，為什麼沒有人要挖掘我？很簡單的道理，因為沒有人知道你作過什麼。沒有文章放在 Blog 上，沒有程式碼放在 Github 上，沒有可以實際端出的 project。光憑短短的幾分鐘面談，和洋洋灑灑履歷。誰能在這麼短的時間，知道你是不世出的曠世奇才呢？</p>

<p>如果你想要世界看到你，你必須要做的就是，主動站出來。</p>

<h3>小結</h3>

<p>現在的社會絕對不是爸媽從小告訴你的那樣：只要專注「上學唸書」，找份「穩定的工作」就能安穩一輩子的社會。相反地，這個社會正用以往沒有的速度，每半年每三個月就快速演化一次。</p>

<p>以具體的例子來說，就看看你身邊的電腦、平板、手機演化趨勢就知道了。2007 年之前有誰能預期到 Facebook 能夠演化成如此怪獸？</p>

<p>世界上的工作型態以及職務需求，也在這幾年間劇烈的變化。昨天在<a href="http://i-chentsai.blogspot.tw/2012/10/korea.html">蔡依澄醫生的部落格</a>上面看到這一段話：『至於台北，他們根本不想拿來比較。我們還在講古老的「四小龍」攀關係，人家已經在亞洲制霸的路上了。』</p>

<p>在台灣媒體的鎖國洗腦下，其實很多人不知道，台灣已完全從先進國家之林掉出去了。很多人以為選出馬英九，即使無能不做事，其實也不可能把國家害到多慘的境界。這真是大錯特錯，在 2007 年以前，台灣與世界的差距真的還沒有那麼大。2008 以後的這黃金四年，全世界都在往前衝，以每三個月一變的速度在進化，只有台灣還在原地沾沾自喜的原地踏步。四年過去了，我們國家以及人民的競爭力完全不知道掉到哪裡去。</p>

<p>我不是跑得很前面的人，我真的只是勉強跟著世界的速度一起跑而已。</p>

<p>很多學弟妹常直接希望我給他們一些將來就業方向上的建議，該選什麼學科好，該選什麼職業好。老實說，在這麼瞬息萬變的社會改變裡，我實在無法告訴大家，什麼職業絕對賺，絕對不會被淘汰。因為這種事已經很難繼續再被持續發生了。</p>

<p>但無論如何，至少我可以告訴大家，如何不被世界變化的速度甩開&#8230;.我認為這三項核心能力是至關重要的。無論社會再怎麼變，至少你還可以靠這三個核心技能維持個人的競爭優勢。</p>

<p>這一篇是關於「什麼技能建議學」。下一篇的主題是「什麼樣的決定不要作」。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在 Hackathon 中獲勝？Paperclip.io 獲獎的背後祕辛]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/20/how-to-win-hackthon/"/>
    <updated>2012-10-20T16:53:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/20/how-to-win-hackthon</id>
    <content type="html"><![CDATA[<p><a href="http://paperclip.io">paperclip.io</a> 是我與 <a href="http://twitter.com/zhusee2">zhusee</a> 最近奪得<a href="https://developers.facebook.com/blog/post/2012/10/15/world-hack-recap-and-winners/"> Facebook World Hack 大賞</a> 的作品。T 客邦在 Facebook 公布大賞得獎名單後 (10/15) <a href="http://www.techbang.com/posts/11030">第一時間採訪了我們</a>。</p>

<p>獲得 <a href="http://techbang.com">T 客邦</a> 授權，將 12 道採訪內容轉貼回來我的部落格。</p>

<hr>


<h4>1、為什麼會選擇開發 Paperclip.io 這樣的服務？你們發現了什麼樣的需求？這個點子是怎麼來的？</h4>

<p>我平常在使用 Facebook 時，到不錯的連結或頁面就會順手按讚。但是，按完讚之後過後想找自己前幾天曾按過什麼連結，卻很麻煩。Facebook 一直沒有一個入口介面可以讓你找之前讚過什麼。我認為這件事造成我相當大的困擾，就覺得應該要有一個開發者來寫一個這樣的 App 幫助大家&#8230;.但很明顯應該是沒有人要寫，於是我就打算自己寫。</p>

<p>剛好 Facebook 舉辦這次比賽，我就打算拿來當這次的題目。</p>

<h4>2 、在 Facebook Developer World HACK 2012 裡面，因為每個站都是一天的活動，而且比賽時間只有幾個小時，在這麼短的時間內，你們做了什麼準備，讓作品可以贏得比賽？</h4>

<h5>選題</h5>

<p>首先，我認為是「選題」吧。這是一個「夠小」而且「解決真正大眾困擾」的題目。如果我們選擇進行這個題目。可能題目賣相就會高一點。（我猜）</p>

<h5>專注</h5>

<p>其次，我認為是「專注」。因為這個「題目」夠小，我們可以把我們的火力集中在於完成核心的實作。主要核心就只是兩隻 API 爬蟲 和網頁爬蟲。這兩個部分很快就寫完了，我們剩下的精力都在調整介面的順暢度。</p>

<h5>賣相</h5>

<p>第三，調整 demo 時的賣相。因為上台前需要寫投影片和 live demo 自己的作品，demo 只有短短的 5 分鐘，我必須在這麼短的時間內讓評審和其他的參賽者，一目了然知道我們的服務在做什麼，解決了什麼問題。於是我註冊了一個假帳號負責 demo，這裡面的內容是我精選過的，可以看完之後就了解我們在做什麼(我本人 like 過的資料其實很雜亂）。 讓評審能夠一下子理解我們想要作什麼，解決了什麼問題。我想也是拉高勝率的一大原因。</p>

<h5>炫技</h5>

<p>第四，介面炫技。zhusee 是一個很強的前端工程師，我經常提了一堆的點子，他馬上就能用很炫的方式實作出來。我們嘗試在 demo 前能夠讓所有的介面非常的流暢（即便是等待時間）。另外也花時間做了高難度的首頁特效，吸引目光焦點（畢竟是 Hackathon….當然要炫耀一下）。</p>

<h4>3、在整個活動過程中，讓你們印象最深刻的事情是什麼？</h4>

<p>參賽的台灣隊伍都很強很有創意。我不知道原來大家會拿 Facebook API 惡搞出這麼多的創意。比如說 Memory Millionaire，我就覺得他們的點子相當有意思。</p>

<p>在宣布三大獎項之後，我們其實一度很失望…一度以為自己落選了。</p>

<p>直到評審宣布評審特別獎，我們發現得獎名單也沒有我們（這也落選會讓我受到很大打擊XD），我們才猜測可能是我們拿到了首獎！！</p>

<h4>4、開發 Paperclip.io 總共用了多少時間？在這個過程中，有沒有遇到什麼樣的難關？</h4>

<p>其實在比賽之前，我有試寫了一個很小的 prototype，練習 FB API 的存取，但是，成品很糟，存在很多問題。但是因為已經熟了 FB API，我大概覺得這個網站主體架構，在比賽的時限之內，我是有把握可以做完的。</p>

<p>原始設計存在不少問題，用改的拿去比賽太麻煩了。我決定到現場重寫一遍。我們從上午九點到會場，就一直馬不停蹄的在寫 code，寫到開始 demo，所以我也不清楚我們整整寫了多久。</p>

<p>不過中間的確有遇到幾個重大難關：</p>

<p>首先是網頁的爬蟲演算法優先順序問題，當初在設計時，設計的 worker 演算法不好，會造成前面使用者資料沒抓完，後面使用者資料就無法開始進行。這在使用者體驗上會非常不好，因為使用者會覺得網站壞掉了。於是我們花了幾乎整整一個小時打掉原先的 worker 重新設計。</p>

<p>再來是搜尋索引效率的問題，我們嘗試讓這些連結是可用關鍵字被搜尋的，但是資料是分批分批抓進來的，所以會有異步索引的問題。我一直都無法好好的解決這個問題，最後心一橫，不解決了。直接用 MySQL 全文檢索…</p>

<p>不然我們可能會被迫在上台前拿掉這個 feature（但我認為搜尋是一個很大的賣點）。</p>

<h4>5、Paperclip.io 隊伍的成員有兩位，你們之間如何分工？</h4>

<p>我（xdite）主寫整個網站的架構，設計爬蟲、梳理流程、製作投影片以及上台簡報。zhusee 實作強大的視覺特效以及繪製精美的 UI。我會先把需要加工的頁面在第一時間寫出來，交給 zhusee 操刀設計，我們用 git 控制程式碼，基本上可以做到全速各寫各的，毫不干擾。</p>

<h4>6、在 Paperclip.io 的功能裡，有個 Recipes 的分類，讓人很好奇為什麼會特別把食譜做個分類出來？又，書本、食譜這兩個分類的內容，是怎麼去判斷的呢？</h4>

<p>在把整個網站初稿寫出來之後，我們認為這個網站如果只有連結實在太單薄了&#8230;.</p>

<p>於是我們決定加一些分類。分類就是按照 og:type 去分，我們發現有幾個 type 做出來的視覺效果不錯，如：Youtube、食譜、Github …於是我們就決定把這些功能加進去了。</p>

<h4>7、在得獎之後，是不是打算升級 Paperclip.io 網站的硬體資源，讓匯入的資料可以更快跑出來？</h4>

<p>這個網站吃的資源真的很驚人，我不確定我能不能一直養著它…</p>

<p>說到這個，其實在現場邀請一些朋友幫忙測試時，我們就發現一些效能上的問題了。於是，我們還在當場做了一個非常大的賭注，就是現場刷卡升級 linode 機器(伺服器)。這時候已經快要接近 demo 時間了，要是升級當場出了什麼問題，或者機器來不及當場升級完畢，我們可能就直接開天窗了… 還好這件事並沒有發生。</p>

<h4>8、對於想要參加類似 Hack 活動的人，有什麼樣的建議？</h4>

<p>我參加過好幾次 Hackathon，得過兩次獎。一次是 2008 年的 Yahoo Open Hack Day（那次是公司同事一起出去比賽，作品是「<a href="http://bingo.handlino.com/">和多繽紛樂</a>」，得了亞軍）。一次就是 2012 年的這次 Facebook World Hack 得到首獎。</p>

<p>在這好幾次的參賽經驗中，我得到幾個寶貴經驗：</p>

<h5>(1) 好的題目很重要</h5>

<p>評審希望得獎的題目是 valuable 的。搞笑、諷刺、主題模糊的題目，一定不會得獎。（我在 2009 的比賽跟一群大神等級的朋友合作做了一個精美的搞笑網站「<a href="http://wp.xdite.net/?p=1472">我是專家</a>」，但是…我們沒有得獎）</p>

<h5>(2) 賣相非常重要</h5>

<p>有些 Hackathon 比賽，甚至投影片比網站重要…。有某幾次的 Hackathon 比賽，竟然是投影片贏了網站。這讓我覺得很不公平也很無奈。但我也理解到比賽要贏就需要賣相的現實。 雖然這次 Hackathon 大會是要求需要提供 source code 以證明不是投影片的實戰比賽，舞弊不至於發生。但我還是認真的投資了快要一個小時在調整假 demo 帳號、截圖、寫投影片&#8230;..</p>

<h4>9、接下來還會參加其他 Hack 活動的計畫嗎？</h4>

<p>暫時沒有。因為我們忘記報名今年的 Yahoo Hack Day 比賽。但我想沒有關係，今年拿到這個獎就值得了…</p>

<h4>10、如何把 Bootstrap 改得這麼好看？</h4>

<p>我們用了一些網路上的免費素材，比如說</p>

<ul>
<li><a href="http://www.google.com/webfonts">Google Web Fonts</a></li>
<li><a href="http://subtlepatterns.com/">Subtle Patterns</a></li>
</ul>


<p>簡單抽換了一下材質，然後用了一點 CSS3 技巧，提升介面質感。這些都是我們平常開發時就相當熟練的技巧，用得很自然。</p>

<h4>11、從零到完成作品，用了很短的時間，這是怎麼做到的？有什麼樣的密技？工作進度如何管理？是有什麼樣的開發好習慣嗎？</h4>

<p>我想主要是幾個重點：</p>

<h5>(1) 時間管理</h5>

<p>我參加過很多場 Hackathon。大概知道寫 code 時最容易踢到什麼鐵板。或者開發中最容易遇到什麼鬼打牆的事情。</p>

<p>比賽通常只有短短的幾個小時，所以你要把最浪費時間的部分想辦法節省掉。比如說：如果當天再討論 idea，你的時間就很有可能不夠用。網站需要佈署，佈署需要測試，所以最好有只要一鍵就能 deploy 的環境。domain name 全球生效需要時間，所以 domain name 最好先買。</p>

<p>現場再搞這些事，網站鐵定作不完。何況最後至少要留半小時寫投影片&#8230;.</p>

<h5>(2) 知道什麼該放棄</h5>

<p>因為時間不夠，所以其實很多功能，不夠時間讓我們寫到夠完美夠好。於是對自己在開發任何元件時，都要設定 deadline。如果一定時間內(15 min&#8217; 30 min)寫不完，就要放棄，或者是改採其他 solution。</p>

<h5>(3) 平常要有自己的 best practices</h5>

<p>作網站的時候，我們知道很多工夫都是重複的。比如說作網站一定要有一個網頁主框架、一個 Facebook 登入系統、一個系統管理介面，一些常見的分享功能。</p>

<p>這些事情都小，但是堆起來還是很花時間。如果比賽時，這部分的時間成本若是 0，我們可以把更多的時間花在寫核心功能上。像我上禮拜釋出的一個 app 產生器 <a href="http://blog.xdite.net/posts/2012/10/12/bootstrappers-create-rails-app/">Bootstrappers</a>。</p>

<p>這個 Bootstrappers 其實就是我這次比賽時用的大砲，它可以讓你一鍵就產生一個網站雛形，然後馬上開始刻程式。所以當別人還在討論要作什麼時，我這部分已經作完了&#8230;.</p>

<p>而我和夥伴已經一起工作將近三個月，彼此有不錯的默契。我們在寫 code 時，了解彼此寫 code 的習慣，於是接力對方的部分，速度就非常快。而我們更用了 git 這套程式碼版本控制系統，可以做到各寫各的，不會干擾。</p>

<h4>12、如果 Facebook 邀請你們加入當員工，會進去嗎？</h4>

<p>會慎重考慮。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paperclip.io win the Grand Prize of Facebook World Hack]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/16/facebook-world-hack-grand-prize-paperclip-io/"/>
    <updated>2012-10-16T01:04:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/16/facebook-world-hack-grand-prize-paperclip-io</id>
    <content type="html"><![CDATA[<p><a href="http://paperclip.io" title="Paerclip.io by xdite, on Flickr"><img src="http://farm9.staticflickr.com/8449/7981727596_abbb2a2de9.jpg" width="500" height="257" alt="Paerclip.io"></a></p>

<p>Hi, everyone. I am happy to announce the new service I recently built at 2012 Facebook World Hack Taipei : 「<a href="http://paperclip.io">Paperclip.io</a>」. Not only won the “Best Overall” prize in Taipei. We also win the <strong>Grand Prize of World Hack</strong> .</p>

<p>News here: <a href="https://developers.facebook.com/blog/post/2012/10/15/world-hack-recap-and-winners/">World HACK Recap and Winners</a></p>

<p>====</p>

<p>We&#8217;re pleased to announce the Grand Prize winners, whose projects stood out from the many high quality apps. These teams have won a trip to Facebook headquarters in Menlo Park, where they will meet with members of the Facebook engineering team:</p>

<p>The Paperclip.io team, from Taipei. Paperclip.io indexes and sorts the things you&#8217;ve liked on Facebook and across the web, so you can easily browse your likes by category or by the date you liked them.</p>

<p>The Chained Story team, from Buenos Aires. Chained Story is a web version of a storytelling game in which players take turns adding a sentence or paragraph to a story. The completed story can be published to a user&#8217;s timeline.</p>

<p>The BoostMate team, from Moscow. BoostMate analyzes your social graph and the connections you have with all your friends, producing a ranking of who you&#8217;re closest to, who you interact with least, and whether those interactions were positive.</p>

<p>====</p>

<p>各位好，前陣子在 Facbook World Hack 奪下<a href="http://blog.xdite.net/posts/2012/09/12/paperclip-io-fb-url-like-service/">台北站首獎</a>的作品<a href="http://paperclip.io">paperclip.io</a>。我們很高興的宣布，這個服務再次奪下了 <strong>Grand Prize of World Hack</strong> 。獎品是前往 Facebook 總部一遊。</p>

<p>我們很高興能為台灣爭了一口氣！謝謝大家一路上的鼓勵！</p>

<p>新聞連結在此：<a href="https://developers.facebook.com/blog/post/2012/10/15/world-hack-recap-and-winners/">World HACK Recap and Winners</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootstrappers 一鍵產生 Rails App with Bootstrap theme]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/12/bootstrappers-create-rails-app/"/>
    <updated>2012-10-12T00:17:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/12/bootstrappers-create-rails-app</id>
    <content type="html"><![CDATA[<p><img src="http://farm9.staticflickr.com/8045/8077515365_44bccfc5c5.jpg" width="500" height="334" alt="Bootstrappers Demo"></p>

<p>這是我本週剛釋出的一個 Gem: <a href="http://github.com/xdite/bootstrappers">Bootstrappers</a>。是一個 Rails 專案產生器，特色是內建馬上套好的 <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> theme 和 其他好東西。</p>

<h2>Bootstrappers 的開發緣由</h2>

<p>身為一個職業開發者，我開啟一個新專案的機會實在太高了。但是，你知道的。每次要開發一個專案，無非就是 <code>rails new project_name</code>。然後打開 Gemfile，添加一些常用 Gem，再修改 <code>application.html.erb</code>，塞塞設定，填填 CSS，修修 HTML。</p>

<p><a href="http://twitter.github.com/bootstrap/">Bootstrap</a> 以及其他 rubygems 是很方便，但是把他們組起來還是非常花時間。次數多了，我就覺得這樣的初始化動作實在很煩。</p>

<p>於是，我第一次的嘗試，就是作一個空專案，把我平常的 best practices 和 templates 都丟進去。如果有開新專案的需求，再 copy 過去。</p>

<p>但是，隨著時間更迭，我又發現更煩的事了。就是我還是得花上一堆時間改 namespace 與 setting。而且，裡面內建的 rubygems 會過期，等於還要花時間 ugprade 這些 template。而最煩的還是：Rails 本身自己也會過期！而要升級的小版本，自己可能還要補一堆 config，而這些變動真的很難追蹤。</p>

<p>於是，最後我下定決心要來研究 App Generator 到底要怎麼寫。我實在受夠了每次的 c/p + modify 了。</p>

<p>（之後我也許會寫一篇如何製作 App 產生器的文章 ）</p>

<p>最後 <a href="http://github.com/xdite/bootstrappers">Bootstrappers</a> 就這樣誕生了。</p>

<h3>內建好康</h3>

<p>這個專案裡面目前內建了以下這些 Gem 以及相關 Template :</p>

<ul>
<li><a href="https://github.com/anjlab/bootstrap-rails">Bootstrap SCSS</a></li>
<li><a href="https://github.com/xdite/bootstrap-helper">Bootstrap Helper</a></li>
<li><a href="https://github.com/plataformatec/simple_form">SimpleForm</a></li>
<li><a href="https://github.com/mislav/will_paginate/">WillPaginate</a></li>
<li><a href="http://compass-style.org/">Compass</a></li>
<li><a href="https://github.com/techbang/seo_helper">SeoHelper</a></li>
<li><a href="https://github.com/capistrano/capistrano">Capistrano</a></li>
<li><a href="https://github.com/njonsson/cape">Cape</a></li>
<li><a href="https://github.com/m-ryan/magic_encoding">Magic encoding</a></li>
<li><a href="https://github.com/binarylogic/settingslogic">Settingslogic</a></li>
<li><a href="https://github.com/airbrake/airbrake">Airbrake</a></li>
<li><a href="https://github.com/newrelic/rpm">NewRelic RPM</a></li>
<li><a href="https://github.com/ndbroadbent/turbo-sprockets-rails3">Turbo Sprockets for Rails 3.2.x</a> Speeds up your Rails 3 rake assets:precompile by only recompiling changed assets</li>
</ul>


<h3>Powerful Features</h3>

<p>特點如下</p>

<ul>
<li>現成套好的 Bootstrap Theme (application.html.erb)</li>
<li>搭配的 Bootstrap Helper，快速兜出表單、選單、按鈕、Dropmenu、ajax modal、alert、breadcrumb 等等…</li>
<li>套好的 WillPaginate (with bootstrap style)</li>
<li>套好的 SimpleForm (with bootstrap style)</li>
<li>內建 Devise 會員系統</li>
<li>Bootstrap useful hacks (比如 <code>body { padding-top:60px }</code>、dropmenu 自動展開等等)</li>
<li><a href="http://blog.xdite.net/posts/2012/08/03/how-to-use-bootstrap-in-clean-way/">Boostrap override best-practices</a></li>
<li>MagicEncoding : Ruby 1.9 自動添加 utf-8 宣告</li>
<li>自動掛上 Compass</li>
<li>SeoHelper : 自動幫你的網站產生 page description / page keywords</li>
<li>Open Graph : 自動幫你的網站產生 og description / og_image</li>
<li>Facebook JS、Google Analytics</li>
<li>Capistrano / Cape</li>
<li>Asset Pipeline 加速器</li>
<li>….etc.</li>
</ul>


<p>一些我平常開發專案時，累積出來的 best practices。</p>

<p>有了這個武器，你現在可以使用 <code>bootstrappers project_name</code> 這個指令，一鍵瞬間就產生出一個不錯的 app，而不用擔心套版問題以及一些基本的網站優化問題。</p>

<p>歡迎 <a href="http://github.com/xdite/bootstrappers">現在就試看看</a> ！</p>

<h2>Bug / Pull Request</h2>

<p><a href="https://github.com/xdite/bootstrappers/issues">https://github.com/xdite/bootstrappers/issues</a></p>

<p>歡迎各位回報錯誤，或者提交 Pull Request。當然，如果能夠直接提交 Pull Request，是最感謝的。</p>

<p>我還會繼續把一些還沒丟進去的 best practices 繼續整合進去。如果各位有興趣幫忙的話，歡迎查看 TODO.md。</p>

<p><a href="https://github.com/xdite/bootstrappers/blob/master/TODO.md">https://github.com/xdite/bootstrappers/blob/master/TODO.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[也許你該停下來聽聽工程師怎麼說]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/07/maybe-you-should-listen-what-your-rd-said/"/>
    <updated>2012-10-07T02:44:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/07/maybe-you-should-listen-what-your-rd-said</id>
    <content type="html"><![CDATA[<p>在我的前一篇文章「<a href="http://blog.xdite.net/posts/2012/10/01/specification-by-example/">Specification by Example - 團隊如何交付正確的軟體</a>」，我提到了一件在工程師界，人人皆知卻不願意說出口的「秘密」：</p>

<blockquote>
「工程師竟然時常比他們的雇主或PM，更了解它的生意邏輯與流程」。
</blockquote>




<blockquote>
「客戶在它的 Spec 裡面卻指定了完全不可行或者是成本效益極低的作法」。因為簽了合約或領了老闆的薪水，我們被迫在明知不可而為之的狀況下，進行了一個徹底失敗的專案。」

</blockquote>


<p>如果你不是身處於工程師這個圈子的話，若無意中聽到這一件事，通常會覺得這群人相當傲慢。這群人不負責執行 Bussiness Development，怎都可大膽有此感想？</p>

<p>一開始，我也對這個「觀察」是存疑的。因為一開始時擁有這個觀察時，我還算是個很菜的工程師，這個觀察對我來說應該是錯覺。但隨著生涯中經歷過許多專案的角色。在專案中，我屢屢嘗試著尋找能夠反駁這個觀察的蛛絲馬跡。但最終都以失敗告終。</p>

<p>而後來更輾轉得知，這幾乎是這個圈子內「不能說出口的秘密」。我才同意這也是真的結論。只是我還是找不出 理論 / 反證。</p>

<p>直到最近，我才從幾段討論中，赫然領悟這件事情也許可能是有一套理論可以解釋的。</p>

<p>一段是從 @yllan （台灣知名 Cocoa 開發者，Nally 作者）在的 <a href="https://www.facebook.com/yllan/posts/10151056527591945">Facebook 的 post</a></p>

<p>====</p>

<p>Steve Jobs 說他很喜歡一個比喻。他以前在 Scientific American 上看到一篇文章，研究各種動物運動的效率，最強的是兀鷹（同樣的運動使用最少能量），人類排名普普通通，可能排在所有動物的三分之一左右。</p>

<p>有趣的是，那篇文章也研究了「騎著腳踏車」的人類，而騎腳踏車的人其能源效率把所有動物遠遠甩在後頭。人類製造工具大幅拓展自己的能力。而 SJ 把「電腦」比喻成「心靈的腳踏車」。</p>

<p>他又認為每個人都應該學程式，因為你在教電腦事情的時候，其實是在釐清自己的思考。這正和 Knuth 的名言「A person does not really understand something until after teaching it to a computer」不謀而合。</p>

<p>====</p>

<p>一段是我在跟與朋友的網路爭辯中，脫口而出寫出來的一段話（我常常從辯論驗證中，突然找到靈感，這些感想甚至是我自己也不知道為何會脫口而出的絕妙結論）：</p>

<p>====</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xdite : RD 會知道你的生意
</span><span class='line'>xdite : 能不能成
</span><span class='line'>xdite : 遠比你自己早知道
</span><span class='line'>xdite : 因為他們會直接先面臨
</span><span class='line'>xdite : 邏輯能不能實作
</span><span class='line'>xdite : 我們會推測就是
</span><span class='line'>xdite : 1. 合理
</span><span class='line'>xdite : 2. 成本（要作多久）
</span><span class='line'>xdite : 3. 效益
</span><span class='line'>xdite : 剛好就是一個事業能不能做的基礎
</span><span class='line'>xdite : 只是很多人誤以為
</span><span class='line'>xdite : RD 只會 code .....
</span><span class='line'>xdite : 3. 效益 就是...能不能重複用
</span><span class='line'>xdite : 能不能實作 要作多久 可不可以重複利用
</span><span class='line'>xdite : 都不可以 就會懷疑
</span><span class='line'>xdite : 你是賺三小</span></code></pre></td></tr></table></div></figure>


<p>====</p>

<p>我終於理解，為什麼 RD 會提早知道這個生意能不能成。這根本的原因就是因為他們便是嘗試教電腦事情的第一線人員。也就是會先面對「釐清」實作上「合不合理」的第一個人。</p>

<p>程式邏輯是非常現實的，若這件事不合理，RD 就會面臨「無法實作」的困境。這是其一。</p>

<p>其二：只有實作的人，才會知道這件事到底要作多久。RD 也許有樂觀病，往往他們告訴你需要實作兩週，但往往真實需要的時間也許是四週。但如果他們告訴你，需要半年這麼久，或者是根本作不出來，沒有完工的可能性。那可能這件事就不可能發生 &#8211; 起碼在他們手上。</p>

<p>同時也應該要注意的是，這直接反應了成本的爆增。有時候，這甚至不是換一批執行團隊可以解決的問題。RD 正在試圖告訴你，執行代價高昂，你最好不要白花錢。因為很現實的，他也不想要白花時間…</p>

<p>其三：所有 RD 都非常討厭寫 event code。所謂 event code 就是只用過一次的 Code（因為某些特殊事件，如廣告、行銷活動，只執行過一次即扔的產品）。這類型的程式碼，往往無法被重新用在下一次的類似事件中，只能重新撰寫重新來過。這對任何重視自己心血結晶的人，重新來過是非常累人非常惱人的事。</p>

<p>而這對生意執行面來說，是非常高昂的沉沒成本。一再發生，甚至是不應被允許的行為。</p>

<h3>小結</h3>

<p>任何賺錢生意無非都是幾個簡單原則：首先，先觀察到一個合理需求。接著針對這個需求設計出一個可執行的解決方案。重複，證明解決方案可以被重製，可以得到收益。接著壓低執行成本，演化出一個可以獲利的模式。而在這段過程中：</p>

<ol>
<li>合理實作</li>
<li>時間成本</li>
<li>重複效益</li>
</ol>


<p>是至關重要的。</p>

<p>世上從來就不存在這麼一個假設：「覺得自己有一個偉大 idea，接著偉大的事情就會發生」</p>

<p>而在整個模式的發生過程，RD 正是日日夜夜都要面對這個挑戰的第一線執行者。</p>

<p>如果他們很坦白的告訴你這個想法很蠢，也許這件事就真的很蠢，你應該停下來聽他們怎麼說…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Specification by Example - 團隊如何交付正確的軟體]]></title>
    <link href="http://blog.xdite.net/posts/2012/10/01/specification-by-example/"/>
    <updated>2012-10-01T04:46:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/10/01/specification-by-example</id>
    <content type="html"><![CDATA[<p><img src="http://z2-ec2.images-amazon.com/images/P/1617290084.01._SX278_SCLZZZZZZZ_V146204546_.jpg" alt="img" /></p>

<p>這個禮拜終於斷斷續續用了空檔時間讀完了一本買了卻一直沒時間坐下來好好研究的書「<a href="http://manning.com/adzic/">Specification by Example</a>」</p>

<p>對岸的圖靈系列最近也出了這本書的中文版:「實例化需求」。如果你想要觀看這本書的書評，InfoQ 上有一篇不錯的文章：「<a href="http://www.infoq.com/cn/articles/specification-by-example-book">《實例化需求》採訪與書評</a>」。</p>

<p>這本書給我一種很奇妙的讀後感，因為書中既沒有程式碼，也不介紹任何工具，甚至實際軟體例子也很少，篇幅最多的甚至是模糊的團隊訪談。</p>

<p>但讀完了以後，卻讓我在軟體開發上流程上有了更大的啟發。</p>

<h3>交付錯誤的軟體的原因</h3>

<p>我是一名職業的軟體開發者。前前後後寫過的軟體專案也有 50 個, 60 個。目前也以開發軟體為生。在我的職業生涯裡面，其實我有一個從來沒有跟人講過的秘密困擾。這個困擾，我相信許多同業們可能也有。那就是 &#8212; 一個專案開發下來，「我們竟然時常比我們的客戶或 PM，更了解它的生意邏輯與流程」</p>

<p>但這個問題帶來更大的困擾是：「客戶在它的 Spec 裡面卻指定了完全不可行或者是成本效益極低的作法」。因為簽了合約或領了老闆的薪水，我們被迫在明知不可而為之的狀況下，進行了一個徹底失敗的專案。</p>

<p>技術很好，團隊也強大，產品也有市場。但還是失敗，因為 &#8211; 「交付錯誤的軟體」。</p>

<h3>軟體工程沒教的課題: 交付正確的軟體</h3>

<p>市面上有很多書，教人如何敏捷開發，教人測試驅動開發（TDD)。它們可以帶給開發者的好處是可以利用這些技巧將工程時間大幅縮短，降低軟體內發生 Bug 的頻率。</p>

<p>這些技巧對於進行軟體專案不是沒有作用，因為早點完工（把功能實做出來），專案早點失敗，專案可以及早軸轉到較接近成功的方向。</p>

<p>對於正在營運中的公司，內部專案早點失敗，及早軸轉到較接近成功的方向。往往是可接受的。因為總體目標是儘快交付到貼近正確方向的軟體。</p>

<p>但對於目標是交付一個軟體的專案，「交付錯誤的軟體」卻往往是糾紛的起源。但卻也是一個千古難解的課題。對於業主來說，他付錢是希望得到一個「正確的軟體」。但於對於被委託的開發者也往往有苦難言，因為他們得到的指示是「按照業主精確的功能敘述去實作軟體」，「正確與否」不是他們的最終責任。而是否「正確」通常往往也得等到上線之後，客戶根據用戶實測反應才能得知（雖然開發者往往是開發階段就往往能猜測出是否失敗的那一群人）。但這從來也不在合約的責任之內。</p>

<p>而這本書也就是在探討這個課題：怎麼樣的軟體流程，才能交付正確的軟體。</p>

<h3>大家沒想到的答案: BDD</h3>

<p>這本書繞了很多遠路去講解什麼是 Specification by example，但這也是作者的用意：刻意不使用專業定義字眼如「敏捷」、「測試驅動開發」去輔助解釋，避免整個梳理的流程被大家腦海裡面的術語印象所綁架。</p>

<p>但總體來說，這個結論毫無疑問就是 Behavior Driven Development (BDD)。不過這個 BDD 卻跟我當初學到的 BDD ( from Cucumber ) 印象很不一樣。這也是為什麼這次會花上幾個小時謄下這篇心得。</p>

<p>裡面有幾段 quote 我很喜歡，實際擊中困擾的核心：摘錄如下：</p>

<p>「實現範圍（Implementation scope）含有對業務問題的解決方案或達成業務目標的手段。很多團隊在開始實現軟件之前（在此之前發生的一切往往被軟件開發團隊所忽略），期望客戶、產品負責人或商業用戶來確定工作的範圍。在商業用戶明確說明他們的需求後，軟建交付團隊就依此時現。這樣本應該會讓客戶滿意。但事實上，這正是構建產品開始出現問題的時候。</p>

<p>如果軟件交付團隊依賴客戶給出用戶故事、用例清單或其他相關信息，那麼他們其實是在讓客戶設計解決方案。但是商業用戶不是軟件設計師。如果我們讓客戶去界定範圍，那麼項目就無法從交付團隊已有的知識受益。這樣開發出來的軟件是客戶所要求的，卻不是他們真正想要的。</p>

<p>成功的團隊不會盲目的接受軟件需求，將其作為未知問題的解決方案，相反，他們會從目標中獲取範圍。他們以客戶的業務目標為起始，然後通過協作界定可以實現目標的範圍。團隊與商業用戶一起工作確定解決方案。商業用戶專注於所需功能希望達到的目的，以及他們期望由此帶來的價值，這樣有助於所有人了解所需的功能。然後團隊提議一個解決方案，這樣比商業用戶自己想出來的方案更實惠、更快，並且更容易交付或維護。」</p>

<p>「與我一起共事過的商業用戶和客戶，大多喜歡把需求描述成解決方案；他們很少會去討論想要達到的目標，或者亟待解決的問題具有什麼特殊性質。我見過太多的團隊有一種危險的誤解，他們認為客戶總是正確的，客戶要求的東西總是一成不變的。這導致很多團隊盲目的接受客戶建議的解決方案，然後竭盡全力去實現。」</p>

<p>「在構建正確軟件產品的過程中，確定範圍扮演著重要的角色。沒有正確的範圍，其餘的工作只是在作無用功。」</p>

<p>「人們告訴你他們自己認為需要什麼，通過問他們『為什麼』，你可以找到背後的目標。許多組織不能明確地指出他們的商業目標。然而，一旦你獲得了目標，就應該再反過來從已確定的目標上獲取範圍，可能你會丟棄掉原先假定出來的範圍」</p>

<h3>一個實際的例子：對 VIP 免費送貨 的需求</h3>

<p>Specification by example 強調的是對於需求，我們必須設計出一個可以被實現的方案，這個方案可以被單獨測試驗證。並且從這個方案與程式碼中演化出 LiveDocument。</p>

<p>書中舉出了一個實際的例子。（整理摘錄）</p>

<p><a href="http://www.flickr.com/photos/xdite/8040169023/" title="Untitled by xdite, on Flickr"><img src="http://farm9.staticflickr.com/8182/8040169023_b634581f99.jpg" width="500" height="375" alt="Untitled"></a></p>

<h5>商業目標</h5>

<p>12 個月內對現有客戶提高 50% 的重複銷售</p>

<h5>實作範圍</h5>

<p>我們可以從商業目標中獲取實現範圍。實現團隊和商業投資者一起提出一些想法，然後把他們分成可交付的軟件塊。比方說我們發現一個主題故事是關於客戶忠誠度計畫的。這個故事可以分解成客戶忠誠度管理系統的基本功能和更高級的獎勵計畫。我們決定首先專注在建立一個基本的會員忠誠度管理系統上：客戶註冊一個 VIP 計畫，VIP 客戶有資格獲得特定物品的免費送貨。我們將推遲關於高級獎勵計畫的討論。下面這個例子的用戶故事：</p>

<ul>
<li>為了能對現有客戶作產品直銷，作為營銷經理，我想讓客戶通過加入 VIP 計畫註冊個人信息。</li>
<li>為了吸引現有客戶註冊 VIP 計畫，作為營消經理，我要系統為 VIP 客戶提供特定物品的免費送貨。</li>
<li>為了節省開支，作為現有客戶，我希望能收到特價優惠的信息。</li>
</ul>


<h5>關鍵實例</h5>

<p>一旦團隊開始實現某個特定的功能，我們就可以為特定的範圍產生具體的需求說明。比如，當我們開始作範圍中的第二項 &#8211; 免費送貨時 &#8211; 必須定義好什麼是免費送貨。在協作討論過程中，為了避免運送電子產品或大件物品相關的後勤問題，我們決定系統只提供書籍的免費送貨服務。因為商業目標是提升重複銷售，我們嘗試讓客戶進行多次購買，「免費送貨」變成了「免費為 5 本或以上書籍送貨」。我們要確定好關鍵實例，比如 VIP 客戶購買 5 本圖書、VIP 客戶購買 5 本以下的圖書，或者非 VIP 客戶購買書籍。</p>

<p>接著討論當客戶同時購買了書籍和電子產品時該怎麼辦。有些人建議擴展範圍，例如，將訂單拆分成兩個，只為書籍提供免費送貨。我們決定推遲這個決定，先實現最簡單的。如果訂單中有非書籍的物品，我們就不提供免費送貨。我們加入下面這個新的關鍵實例，之後會再討論。</p>

<h6>關鍵實例：免費送貨</h6>

<ul>
<li>VIP 客戶購物車中有 5 本書籍可以獲得免費送貨</li>
<li>VIP 客戶購物車中有 4 本書及就不提供免費送貨</li>
<li>普通客戶購物車中有 5 本書籍沒有免費送貨</li>
<li>VIP 客戶購物車中有 5 台洗衣機時不提供免費送貨</li>
<li>VIP 客戶購物車中有 5 本書籍和 1 台洗衣機時不提供免費送貨</li>
</ul>


<h5>帶實例的需求說明</h5>

<p>我們從關鍵實例中提煉出需求說明、創建出一目了然的文檔並將其格式化成便於今後作自動化驗證的格式（如下所示）</p>

<h6>免費送貨</h6>

<ul>
<li>當VIP 客戶購買一定數量的書籍時，提供免費送貨。免費送貨不提供給普通用戶或購買非書籍的 VIP 客戶。</li>
<li>假定至少買 5 本書才能獲得免費送貨服務，那麼我們會得到以下預期：</li>
</ul>


<p>Example:</p>

<table>
<thead>
<tr>
<th></th>
<th>客戶類型</th>
<th>購物車中的物品</th>
<th>送貨</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> VIP </td>
<td> 5 本書 </td>
<td> 免費、標準 </td>
</tr>
<tr>
<td></td>
<td> VIP </td>
<td> 4 本書 </td>
<td> 標準 </td>
</tr>
<tr>
<td></td>
<td> 普通 </td>
<td> 10 本書 </td>
<td> 標準 </td>
</tr>
<tr>
<td></td>
<td> VIP </td>
<td> 5 台洗衣機 </td>
<td> 標準 </td>
</tr>
<tr>
<td></td>
<td> VIP </td>
<td> 5 本書、1台洗衣機 </td>
<td> 標準 </td>
</tr>
</tbody>
</table>


<p>這個需求說明 &#8212; 一目了然的文檔 &#8211; 可以用作實現的目標或自動化測試的驅動，這樣我們就可以客觀地衡量什麼時候算完成了。把它作為 LiveDocument 的一部分，保存在需求說明 Repository 中。FitNesse 的 wiki 系統或者 Cucumber 功能文件的目錄結構就是這樣的例子。</p>

<h5>可執行的需求說明</h5>

<p>當開發人員開始實現需求說明所描述的功能時，基於需求說明的測試開始時會失敗，因為測試還沒有自動化，功能也還沒有實現。</p>

<p>開發人員會實現相關功能並把它與自動化框架關聯在一起。他們使用自動化框架從需求說明中獲得輸入並驗證預期的輸出，而不需要實際修改需求說明文檔。當驗證實現自動化以後，需求說明就變成可執行的了。</p>

<h5>Live Document</h5>

<p>所有已實現功能的需求說明需要頻繁地進行驗證，一般通過自動化構建過程來實現。這樣可以確保需求說明保持更新，同時有助於避免功能退化的問題。</p>

<p>當實現了整個用戶故事的時候，需要有人去作首次驗證以確保其已經完成，然後重組需求說明確保它和已實現功能的需求說明是一致的。從需求說明逐步演化出文檔系統。舉例來說，他們可能將免費送貨的需求移到送貨相關的功能體系中，也可能將它們和其他因素促發的免費送貨實例合併在一起。為了更容易訪問文檔，他們可能會在免費送貨的需求說明和其他送貨類型的需求說明之間建立連結。</p>

<p>然後這個循環再次開始。一旦我們需要再次回顧免費送貨的規則 &#8211; 比如，在做高級獎勵計畫，或是擴展功能把帶書籍的訂單和其他貨物訂單分離開的時候 &#8211; 我們就可以使用 Live Document 來理解現有的功能並註明需要修改的地方。我們可以使用已有的實例來協作制定需求說明，同時舉例說明會更加有效。然後我們會舉出另一組關鍵實例，進一步演進免費送貨的需求說明，這部分最終會和需求說明的其他部分合併到一起。這個循環會不斷重複。</p>

<h3>為何 BDD 沒有 TDD 那麼流行？</h3>

<p>如果你身為 Rails Developer 又看到這套循環格式的話，你會馬上感到這跟一套測試框架很像，沒錯，就是 <a href="http://cukes.info/">Cucumber</a>。</p>

<p>我第一次接觸到 BDD 的觀念大概是 2009 年。當然也是因為接觸到 Cucumber，才知道什麼叫做 BDD。但是一直以來，我能夠接受 TDD，但是 BDD 卻一直讓我無法理解。事實上，BDD 也一直沒有普遍流行起來</p>

<p>現在看完這本書，我才理解是什麼的盲點造成了實作上的心理障礙：在一般的專案開發中，通常業主不會要求開發者寫測試（甚至業主不理解什麼叫測試），所以通常測試是開發者自己寫的，為了正確構建功能，以及避免在專案後期踢到大鐵板，所寫的。</p>

<p>但是 BDD 的格式乍看之下卻相當突兀，以 Cucumber 為例，格式是這樣的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="no">Scenario</span><span class="p">:</span> <span class="no">Multiple</span> <span class="no">Givens</span>
</span><span class='line'>    <span class="no">Given</span> <span class="n">one</span> <span class="n">thing</span>
</span><span class='line'>      <span class="no">And</span> <span class="n">another</span> <span class="n">thing</span>
</span><span class='line'>      <span class="no">And</span> <span class="n">yet</span> <span class="n">another</span> <span class="n">thing</span>
</span><span class='line'>    <span class="no">When</span> <span class="n">I</span> <span class="nb">open</span> <span class="n">my</span> <span class="n">eyes</span>
</span><span class='line'>    <span class="no">Then</span> <span class="n">I</span> <span class="n">see</span> <span class="n">something</span>
</span><span class='line'>      <span class="no">But</span> <span class="n">I</span> <span class="n">don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">see</span> <span class="n">something</span> <span class="k">else</span>
</span></code></pre></td></tr></table></div></figure>


<p>敘述一個場景，然後寫下步驟，然後驗證步驟。這對一般開發者來說，BDD 相對多餘以及冗長。</p>

<p>原因何在？這是一般專案中，通常我們只會遇到兩種狀況：</p>

<ul>
<li>客戶疏於描述實作內容 : 只給解決方案，如必須要能夠進行付款。（但是卻沒有講清楚支援信用卡還是 ATM）</li>
</ul>


<p>所以所謂 BDD 裡面的用戶故事，開發者必須要自行腦內補完。於是只要當「規格」一變，基於規格所生(想像)的整個用戶故事自然就會被摧毀。所以沒有人很喜歡寫這鬼東西。</p>

<ul>
<li>客戶過於精確的描述：對於描述操作步驟過於繁瑣，甚至是規定 UI （比如結帳必須要跳出一個 POP 視窗，等待信用卡驗證時必須要塞入一個等待過場動畫）</li>
</ul>


<p>這又會變成另外一種情形，開發者把 BDD 當作是 UI 的驗收測試（尤其在使用 Cucumber 中特別容易被誤解）。在網站開發過程中，UI 很有可能是會變來變去的。沒有人會喜歡因為 UI 改變了然後又回去翻修用戶故事&#8230;.</p>

<p>這就造成了為什麼人們寧願只進行 TDD，甚至只進行 Unit Test。因為比較不可能被需求變動整到。</p>

<p>但只進行 TDD 只能幫助我們：正確地開發一個產品。卻無法達到我們進行軟體開發最終的目標：「開發出一個正確的產品」。</p>

<h3>Startup 前期應不應該導入 TDD / BDD？</h3>

<p>在去年，我曾經寫過一篇 <a href="http://wp.xdite.net/?p=2478">對 BDD / TDD 的看法</a>，提到 Obie Fernandez 在 Rails Conf 2011 的 lightning talk 曾經給過這樣一個 lighting talk : Why BDD is Poison For Your Early Stage Startup 。並且在演講之後寫了一篇文章 <a href="http://blog.obiefernandez.com/content/2011/05/the-dark-side-beckons.html">The Dark Side Beckons?</a></p>

<p>Obie 的觀點正如 talk 名 &#8220;Why BDD is Poison For Your Early Stage Startup&#8221; 所言。他並且強調了：「Early on in the startup process, it&#8217;s much more important to be testing against business metrics than anything having to do with code.」</p>

<p>「Until you are able to prove that you have a viable market, that customers will give you money for your product, you shouldn&#8217;t be sinking a lot of time and money into implementation.」</p>

<p>現在回頭看起來，當時的討論完全是掉入方法論面的論述。我們以為 TDD / BDD 是「正確地開發一個產品」的一個手段。但這個手段會有相對高額的 technical cost。所以在 Startup 早期階段，開發者實際不應該投入過多心力在此之上。因為 Startup 的第一優先是「開發出一個正確的產品」。</p>

<p>而 Specification by example 卻強調的是，你應該透過這一系列的手段，利用 BDD 這樣的手法，摸索出一系列可以實作可以測試的正確軟體需求，從而交付出一個成功的軟體專案。</p>

<h3>小結</h3>

<p>如果你是抱著裡面有什麼厲害的大絕招，去翻這本書的話。我不敢保證你不會失望。因為這本書不太能算是一本嚴肅的方法論。裡面沒有 code，也不介紹任何工具。同時我也不推薦任何專案新手去翻閱這本書，因為這本書並不是什麼印度蛇藥，你一看完就會變成專案高手。</p>

<p>但是若你進行過不少專案，對於測試驅動開發、行為驅動開發、探索用戶需求有著自己的一番見解、疑問、心得。我相信這本書將會顛覆你的世界觀。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[paperclip.io : track urls you ever liked]]></title>
    <link href="http://blog.xdite.net/posts/2012/09/12/paperclip-io-fb-url-like-service/"/>
    <updated>2012-09-12T22:23:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/09/12/paperclip-io-fb-url-like-service</id>
    <content type="html"><![CDATA[<p><a href="http://paperclip.io" title="Paerclip.io by xdite, on Flickr"><img src="http://farm9.staticflickr.com/8449/7981727596_abbb2a2de9.jpg" width="500" height="257" alt="Paerclip.io"></a></p>

<p>Hi, everyone. I want to introduce the new service I recently built at 2012 Facebook World Hack Taipei : 「<a href="http://paperclip.io">Paperclip.io</a>」. It is also the &#8220;Best Overall&#8221; service in Facebook World Hack Taipei.</p>

<h2>What is Paperclip.io?</h2>

<p>Paperclip.io tracks and collects webpages you liked via Facebook, and organizes them for you. You can browse or search through the liked pages quickly in Paperclip.io.</p>

<h3>idea from …</h3>

<p>The idea was from a small thing: I always forget what url I ever liked on Facebook. It was really annoying. So finally I decide to build a service to help me to collect and organize this url links.</p>

<h3>Features</h3>

<ul>
<li>automatic tracking and backup</li>
<li>organized by various types, provides url info  and snapshots.</li>
<li>can reshare to google plus+, twitter, del.icio.us…etc</li>
<li>searchable!!</li>
</ul>


<h3>demo video</h3>

<iframe width="560" height="315" src="http://www.youtube.com/embed/FM6FOl4frRc" frameborder="0" allowfullscreen></iframe>


<p>video creditd by htchien</p>

<h3>like us on Facebook:</h3>

<p><a href="https://www.facebook.com/paperclip.io">https://www.facebook.com/paperclip.io</a></p>

<p>======</p>

<p>各位好。這是我昨天才剛推出的新服務「<a href="http://paperclip.io">paperclip.io</a>」。這個服務的主旨是要解決一個困擾：我們每天在 Facebook 上都會「讚」過很多網址。但是，就是因為「讚」過的東西太多了，每次要回去找今天或前幾天讚過什麼東西，都很麻煩。</p>

<p>所以最後我決定寫了一個服務來解這樣的困擾，它可以：</p>

<ul>
<li>每天自動備份你曾經「讚」過什麼</li>
<li>按照 og:type 分類排好，而且有縮圖、大綱，</li>
<li>還可以讓你容易再度的分享到其他服務（如 Google+, twitter）去。</li>
<li>最棒的是可以搜尋！！也就是可以快速搜尋你曾經到底「讚」過什麼鬼了！</li>
</ul>


<p><a href="http://www.flickr.com/photos/xdite/7981771741/" title="螢幕快照 2012-09-11 下午7.10.01 by xdite, on Flickr"><img src="http://farm9.staticflickr.com/8180/7981771741_e6f28baf19_n.jpg" width="320" height="208" alt="螢幕快照 2012-09-11 下午7.10.01"></a></p>

<p>看了 <a href="http://youtu.be/FM6FOl4frRc">demo 影片</a>就知道！</p>

<p>這個服務也讓 我跟夥伴 <a href="http://twitter.com/zhusee2">zhusee</a> 同時奪得了 2012 Facebook World Hack 台北站的首獎 (Best Overall)</p>

<p>歡迎各位試用！</p>

<p>如果使用上有什麼 bug 的話，請在這篇文章底下留言。我會儘快處理…</p>

<p>P.S. 因為機器小台，而且光今天用戶就瞬間爆增幾百個&#8230;，所以有可能你剛剛匯入的東西有可能不會那麼快跑出來，這目前不是 bug…還請見諒。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9/12 - 9/20 在舊金山]]></title>
    <link href="http://blog.xdite.net/posts/2012/09/05/912-920-in-sf/"/>
    <updated>2012-09-05T09:17:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/09/05/912-920-in-sf</id>
    <content type="html"><![CDATA[<p>我 9/12 - 9/20 會在舊金山。參加 9/14, 9/15 的 <a href="http://gogaruco.com">Golden Gate Ruby Conf</a> 。</p>

<p>如果有灣區的讀者想晚上吃個飯小酌，歡迎寫信給我 :D  (xdite AT rocodev.com)</p>

<p>P.S. 我住 San Francisco 的 Mission District</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Twelve-Factor App 宣言]]></title>
    <link href="http://blog.xdite.net/posts/2012/09/03/12-factor-app/"/>
    <updated>2012-09-03T12:56:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/09/03/12-factor-app</id>
    <content type="html"><![CDATA[<p>這是前陣子在 <a href="http://www.lonestarrubyconf.com/">LoneStarRubyConf 2012</a> 上複習一些主題時，無意中翻到的一份宣言。</p>

<p>這份宣言我是從 Heroku 的工程師 Richard Schneeman 發表的這份 talk :<a href="https://speakerdeck.com/u/schneems/p/millions-of-apps-deployed-presented-at-lsrc">Millions of Apps Deployed: What We&#8217;ve Learned</a> 裡面翻到的。（不是很多人關注到。這份投影片我看到時才 100 Views 左右）</p>

<script async class="speakerdeck-embed" data-id="50254cb6af597c0002005bf3" data-ratio="1.3333333333333333" src="http://blog.xdite.net//speakerdeck.com/assets/embed.js"></script>


<p>這篇投影片相當精彩，內容是從一份宣言 <a href="http://12factor.net">12factor.net</a> 出發。列舉了十二項構建 Service as Service 所需的方法主題，再以如何使用 Rails 及其 Ecosystem 搭建出 Twelve-Factor App 宣言裡的需求條件為主旨展開。</p>

<p>因為這份投影片的內容，其實我在兩三年前就想寫過系列文章，但因為是一份相當宏大且沒有邊界（就當時來看）的主題，因此一直遲遲無法完成。社群內有人能夠整理出來，覺得實在太棒了。</p>

<p>不過我更好奇的是，若這能是一份非 Rails 為主軸的內容，影響層面應可以更大。念頭剛起，我就發現投影片的源頭出處 <a href="http://12factor.net">12factor.net</a> 的這份宣言原本就是 language-agnostic based 的。</p>

<p>這麼宏大的主題，若是一個社群阿貓阿狗所寫，想必沒有說服力。但順著線索摸下去，我更發現 <a href="http://www.12factor.net/">The Twelve-Factor App</a> 這份宣言的起草人不是別人，正是 <a href="http://heroku.com">Heroku</a> 的 Founder: Adam Wiggins。宣言的內容是他基於運營 Heroku 以來，公司經手過數十萬 Application 歸納出的結論。</p>

<p>這份宣言在上禮拜已有人翻成簡體中文版 <a href="http://www.harmy.me/the-twelve-factor-app.html">The Twelve-Factor App</a>，我推薦各位絕對要去讀完&#8230;</p>

<hr>


<p>(以下轉錄中文簡介，並對用語酌量修改)</p>

<h4>簡介</h4>

<p>如今，軟體通常會作為一種服務來交付，它們被稱為網路應用程式，或「軟體即服務」（SaaS）。「十二因子應用程式」（12-Factor App）為構建如下的SaaS應用提供了方法論：</p>

<p>使用標準化流程自動配置，從而使新的開發者花費最少的學習成本加入這個項目；
和操作系統之間盡可能的劃清界限，在各個系統中提供最大的可移植性；
適合部署在現代的雲計算平台，從而在服務器和系統管理方面節省資源；
將開發環境和生產環境的差異降至最低，並使用持續交付實施敏捷開發；
可以在工具、架構和開發流程不發生明顯變化的前提下實現擴展；
這套理論適用於任意語言和後端服務（資料庫、Message Queue、Cache等）開發的應用程式。</p>

<h4>背景</h4>

<p>本文的貢獻者者參與過數以百計的應用程式的開發和部署，並通過Heroku平台間接見證了數十萬應用程式的開發，運作以及擴展的過程。</p>

<p>本文綜合了我們關於SaaS應用幾乎所有的經驗和智慧，是開發此類應用的理想實踐標準，並特別關注於應用程式如何保持良性成長，開發者之間如何進行有效的代碼協作，以及如何避免軟件污染。</p>

<p>我們的初衷是分享在現代軟體開發過程中發現的一些系統性問題，並加深對這些問題的認識。我們提供了討論這些問題時所需的共享詞彙，同時使用相關術語給出一套針對這些問題的廣義解決方案。本文格式的靈感來自於 Martin Fowler的書籍：<a href="http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC">Patterns of Enterprise Application Architecture</a>，<a href="http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C">Refactoring</a>。</p>

<h4>讀者應該是哪些人？</h4>

<p>任何SaaS應用的開發人員。部署和管理此類應用的運維工程師。</p>

<h4>The Twelve Factors</h4>

<h5>I. Codebase</h5>

<p>One codebase tracked in revision control, many deploys</p>

<h5>II. Dependencies</h5>

<p>Explicitly declare and isolate dependencies</p>

<h5>III. Config</h5>

<p>Store config in the environment</p>

<h5>IV. Backing Services</h5>

<p>Treat backing services as attached resources</p>

<h5>V. Build, release, run</h5>

<p>Strictly separate build and run stages</p>

<h5>VI. Processes</h5>

<p>Execute the app as one or more stateless processes</p>

<h5>VII. Port binding</h5>

<p>Export services via port binding</p>

<h5>VIII. Concurrency</h5>

<p>Scale out via the process model</p>

<h5>IX. Disposability</h5>

<p>Maximize robustness with fast startup and graceful shutdown</p>

<h5>X. Dev/prod parity</h5>

<p>Keep development, staging, and production as similar as possible</p>

<h5>XI. Logs</h5>

<p>Treat logs as event streams</p>

<h5>XII. Admin processes</h5>

<p>Run admin/management tasks as one-off processes</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cache Digests 最大化緩存策略]]></title>
    <link href="http://blog.xdite.net/posts/2012/09/02/cache-digest-new-strategy/"/>
    <updated>2012-09-02T20:06:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/09/02/cache-digest-new-strategy</id>
    <content type="html"><![CDATA[<p><a href="http://www.flickr.com/photos/ferguson666/3605271302/" title="Russian Dolls 097 by Louise...6661, on Flickr"><img src="http://farm3.staticflickr.com/2473/3605271302_0532598c8f.jpg" width="500" height="333" alt="Russian Dolls 097"></a></p>

<p>大概半個月之前（2012/ 8/13 前後），<a href="http://twitter.com/dhh">@dhh</a> 釋出了一個有關於 cache 的 gem，叫做 <a href="https://github.com/rails/cache_digests">cache_digests</a>，並宣布此 gem 會成為 Rails 4 中的一部分。</p>

<p>既然會是主體的一部分，想必這個 gem 解決的問題非常重要。但無奈 README 也非常簡略，看不出重要性在哪。還花了我一點時間在網路上找資料，把 DHH 想要表達的哲學拼出來&#8230;.</p>

<h3>從 new Basecamp 改版談起</h3>

<p>@dhh 的公司 <a href="http://37signals.com">37signals</a> 旗下最有名的產品 <a href="http://basecamp.com">Basecamp</a> 大概半年前改版了。與其說是改版，不如說是整個大重寫了。撇開使用性不談（好用度大幅提高），Website Performance 整體也大幅提升。</p>

<p>37signals 在大概二月發表了一篇文章，談了這次的版本為什麼效能變得這麼好：</p>

<h4>1. Turn to JavaScript Applicaton</h4>

<p>眾所皆知（?）的這次的改寫重點是在 JavaScript 上，整個 codebase 中CoffeScript 與 Ruby 的比例到達了 1:1 之譜。也就是 new Basecamp 實質上是個「JavaScript Application」。另外再利用 Stacker (advanced puhState-based engine for sheets) 大幅降低 HTTP requests。</p>

<h4>2. Cache TO THE MAX: Russian Doll cache stratgy</h4>

<p>雖然 new Basecamp 已經是個 「JavaScript Application」。但有個問題還是存在，身為 backend 的 Rails App 在 render Basecamp 的邏輯時，速度還是不夠快。於是他們採用「Russian Doll」的 Cache Strategy 把能 Cache 的部分擴展到上限…</p>

<h3>Russian Doll cache strategy</h3>

<p>如名所示，Russian Doll strategy，就是使用層層 cache 嵌套的策略。</p>

<p><img src="http://s3.amazonaws.com/37assets/svn/777-russian-doll-caching-1.png" alt="image" /></p>

<p>這一張圖片的背後 code 會是這樣的寫法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@project</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">  aaa</span>
</span><span class='line'><span class="sx">  &lt;% cache @todo do %&gt;</span>
</span><span class='line'>    <span class="n">bbb</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@todolist</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">      ccc</span>
</span><span class='line'><span class="sx">    &lt;% end %&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="sx">% end %&gt;</span>
</span><span class='line'><span class="sx">&lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>再利用 Rails 內建 cache helper 使用 <code>"#{cache_key}/#{id}-#{timestamp}"</code> (<a href="http://apidock.com/rails/ActiveRecord/Base/cache_key">出處</a>) 的方式去實作 cache invalidation。如此一來，只要 object 被變更，cache 就會被刷新。</p>

<p>但這招即使如此直觀，還是會遇到 invalidation 上的幾個問題。</p>

<h4>1. 更新了 todolist，但是上層 class: todo 卻不知道…</h4>

<p>todlist 更新了，所以 updated_at 會被更新。不過 todo 卻不知道 todolist 的更新，所以整塊並不會被更新。</p>

<h5>解法：</h5>

<p>不過解法容易。可以透過 <code>belongs_to :todo, :touch =&gt; true</code>，<code>belongs_to :product, :touch =&gt; true</code>。從最底部的 todolist，層層連鎖更新到最上層。</p>

<h4>2. 更新了 code block，但 object 內容卻因為沒更新而不會 expire。</h4>

<p>當我把 ccc 改成 zzz 時且打算 deploy 時，問題來了&#8230;。整套 cache 機制是基於 object 更新，而不是 code 更新。所以 cache 並不會 invalid….</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@project</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">  aaa</span>
</span><span class='line'><span class="sx">  &lt;% cache @todo do %&gt;</span>
</span><span class='line'>    <span class="n">bbb</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@todolist</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">      zzz</span>
</span><span class='line'><span class="sx">    &lt;% end %&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="sx">% end %&gt;</span>
</span><span class='line'><span class="sx">&lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h5>解法：</h5>

<p>這邊有另外一個寫法可以閃過這個地雷，就是為這整段 code 加上版本號：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sx">% cache </span><span class="o">[</span><span class="n">v15</span><span class="p">,</span><span class="vi">@project</span><span class="o">]</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">  aaa</span>
</span><span class='line'><span class="sx">  &lt;% cache [v10,@todo] do %&gt;</span>
</span><span class='line'>    <span class="n">bbb</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="sx">% cache </span><span class="o">[</span><span class="n">v45</span><span class="p">,</span><span class="vi">@todolist</span><span class="o">]</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">      zzz</span>
</span><span class='line'><span class="sx">    &lt;% end %&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="sx">% end %&gt;</span>
</span><span class='line'><span class="sx">&lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我要將 todolist block 那塊更新，要強制 invalid，我可以把 <code>v45</code> 改成 <code>v46</code>。這樣就更新了。</p>

<p>不過如果這一塊 view 上面還有外層 cache 嵌套，<code>v10</code> 要跟著變成 <code>v11</code>，<code>v15</code> 要跟著變成 <code>v16</code>。</p>

<p>有點麻煩了…</p>

<p>但這還不是最糟糕的…</p>

<h4>3. cache 的部分散落在 partial 裡面，版本號更新不易</h4>

<p>改版本號麻煩但還算可以接受。但這只限於都在同一張 view 裡面的狀況。</p>

<p>若是 cache 被放在 partial 裡面，被多個 view 引用呼叫，那就麻煩了…</p>

<p><code>_todolist.html.erb</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sx">% cache </span><span class="o">[</span><span class="n">v45</span><span class="p">,</span><span class="vi">@todolist</span><span class="o">]</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">  zzz</span>
</span><span class='line'><span class="sx">&lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>改版本號的手續就變成地獄了…。因為你永遠都會有忘記清掉的 view…</p>

<p>解法：</p>

<p>暫無。認命的改吧（？）</p>

<h3>4. 逐漸冗長的 syntax 問題..</h3>

<p>而使用版本號閃避 cache 還會造成，原本直觀的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@todolist</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">    zzz</span>
</span><span class='line'><span class="sx">  &lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>為了要 invalid cache 的問題，被迫使用 trick 去 bypass。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="o">&lt;</span><span class="sx">% cache </span><span class="o">[</span><span class="n">v45</span><span class="p">,</span><span class="vi">@todolist</span><span class="o">]</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">    zzz</span>
</span><span class='line'><span class="sx">  &lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可不可以單純一點，我們寫 code 還是回到直觀的 <code>cache @object</code>，然後以上談到的這些問題都會自動解決？</p>

<h3>cache_digests 就是這一切的答案：md5_of_this_view</h3>

<p><a href="https://github.com/rails/cache_digests">cache_digests</a> 就是 DHH 解決這一切惱人問題的手段。</p>

<p>而且解決策略也非常簡單，既然大家都在版本號上面 GGYY，那麼其實最快的方式就是 <strong>md5_of_this_view</strong> ！！！</p>

<p><a href="https://github.com/rails/cache_digests">cache_digests</a> 允許開發者繼續使用這樣的 code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="o">&lt;</span><span class="sx">% cache </span><span class="vi">@todolist</span> <span class="k">do</span> <span class="sx">%&gt;</span>
</span><span class='line'><span class="sx">    zzz</span>
</span><span class='line'><span class="sx">  &lt;% end %&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但！cache_digests 自動幫忙計算此 block 裡面的 code 產出的內容的 md5，以此 md5 作為 cache key，從而達到自動 invalid 的效果。</p>

<p>同時，這個 gem 也會自動解決層層嵌套的 dependency 問題…</p>

<h3>小結</h3>

<p>這一個 gem 前前後後不到 150 行。卻解決了一個非常重要的 cache 問題，也難怪會變成 Rails 4 之後內建的功能。</p>

<p>gem 雖然直觀。不過翻出這些前因後果還真是不簡單，在寫這篇文章的確也花了我花了一點時間去蒐集資料。從 37signals 釋出的一些小片段去把內容組出來。</p>

<p>相關連結：</p>

<ul>
<li><a href="http://37signals.com/svn/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui">How Basecamp Next got to be so damn fast without using much client-side UI</a></li>
<li><a href="http://37signals.com/svn/posts/3113-how-key-based-cache-expiration-works">How key-based cache expiration works</a></li>
<li><a href="http://www.youtube.com/watch?v=FkLVl3gpJP4#t=33m30s">Evening on Backbone.js/Views w/ Q&amp;A with David Heinemeier Hansson</a></li>
<li><a href="http://www.broadcastingadam.com/2012/07/advanced_caching_part_2-using_strategies/">Advanced Caching: Part 2 - Using Caching Strategies</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails-with-massive-data]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/22/rails-with-massive-data/"/>
    <updated>2012-08-22T00:20:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/22/rails-with-massive-data</id>
    <content type="html"><![CDATA[<p>這是我今天在 Ruby Tuesday #21 所寫的投影片。以下文章是寫投影片前已經擬好的草稿。可以配著服用</p>

<script async class="speakerdeck-embed" data-id="5030bd74edfca8000202c365" data-ratio="1.299492385786802" src="http://blog.xdite.net//speakerdeck.com/assets/embed.js"></script>


<p>Rails Developer 在使用內建工具開發網站時，若是由小做起，通常不會踩到這些雷。但是若一開始開站資料就預計會有 10 萬筆、甚至 100 萬筆資料。執行 db 的 rake task 通常往往會令人痛苦不堪。</p>

<p>在這篇文章內，我整理了一些處理巨量資料必須注意的細節，應該可以有效解決大家常遇到的問題：</p>

<h3>1. 盡量避免使用 ActiveRecord Object</h3>

<p>ActiveRecord 當初的設計目的是為了框架內「商業使用」。它的工作是將純資料化為具有商業邏輯的 Ruby Object，並且配合框架，設計了多層 callbacks。</p>

<p>簡單來說，它並不是為了「處理 raw data」而設計。如果開發者只是要作一些簡單的資料操作，建議的方式請直接下 SQL，不要沾到任何 ActiveRecord。</p>

<p>（但大多數開發者直覺都是會開 ActiveRecord 下了條件就直接跑迴圈，忘記 MySQL 是可以直接拿來下指令的）</p>

<p>當然，沒有 ActiveRecord 這麼抽象化的工具，下純指令也是蠻痛苦的一件事，我推薦可以換用 <a href="http://sequel.rubyforge.org/">sequel</a> 這套工具試看看。</p>

<p>再者，在實務操作上我也建議避免使用 ActiveRecord + 內建的 rake task 操作巨量資料。原因是，開發者會順帶會把整套的 Rails 環境都載進來跑，其慢無比是正常的…</p>

<h3>2. 有 update_all 可以用，少用 for / each。</h3>

<p>通常會出問題的 code 是長這樣的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">posts</span> <span class="o">=</span> <span class="no">Post</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">:board_id</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class='line'>  <span class="n">post</span><span class="o">.</span><span class="n">board_id</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">post</span><span class="o">.</span><span class="n">save</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>這段 code 非常直觀，但會造成許多的問題。如果符合的條件有 10 萬筆，大概放著跑一天都跑不完&#8230;.</p>

<p>先提供快速解法。Rails 提供了 <a href="http://apidock.com/rails/ActiveRecord/Base/update_all/class">update_all</a> 可以下。可以改成這樣</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span><span class="o">.</span><span class="n">update_all</span><span class="p">({</span><span class="ss">:board_id</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="ss">:board_id</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>基本上就是等於直接幫你下 update 的 SQL 啦。同樣資料量跑下去大概只要 10 秒秒以下左右吧。</p>

<h3>3. 不要傻傻的直接 Post.all.each，可以用 find_in_batches</h3>

<p>直接叫出所有符合的資料（Array) 是一件危險的事。如果符合條件的資料是 10 萬筆，全拉出來有高達 10G 的大小，嗯…我想機器沒個 10 G 以上的記憶體，指令下去機器直接跑到死掉有極大的可能性…</p>

<p>Rails 提供了 find_in_batches</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span><span class="o">.</span><span class="n">find_in_batches</span><span class="p">(</span><span class="ss">:conditions</span> <span class="o">=&gt;</span> <span class="s2">&quot;board_id = 5&quot;</span><span class="p">,</span> <span class="ss">:batch_size</span> <span class="o">=&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">posts</span><span class="o">|</span>
</span><span class='line'>  <span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class='line'>    <span class="n">post</span><span class="o">.</span><span class="n">board_id</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">post</span><span class="o">.</span><span class="n">save</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果沒下 batch_size 預設一次是拉 2000 筆。可以一次指定小一點的數目，如一次 500 筆去跑。</p>

<h3>4. 使用 transaction 跳過每次都要 BEGIN COMMIT 的過程，一次做完 1000 筆，然後再 COMMIT。</h3>

<p>打開 Rails 的 development.log，這樣的 LOG 應該對你不陌生。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>   <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>  <span class="k">BEGIN</span>
</span><span class='line'>   <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="n">ms</span><span class="p">)</span>  <span class="no">COMMIT</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rails 開發時，為了確保每比資料正確性，儲存的時候都會過一次 transaction，於是即使已經照 <code>3</code> 這樣的解法，還是要過 10 萬次 COMMIT BEGIN。很浪費時間。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span><span class="o">.</span><span class="n">find_in_batches</span><span class="p">(</span><span class="ss">:conditions</span> <span class="o">=&gt;</span> <span class="s2">&quot;board_id = 5&quot;</span><span class="p">,</span> <span class="ss">:batch_size</span> <span class="o">=&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">posts</span><span class="o">|</span>
</span><span class='line'>  <span class="no">Post</span><span class="o">.</span><span class="n">transaction</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class='line'>      <span class="n">post</span><span class="o">.</span><span class="n">board_id</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="n">post</span><span class="o">.</span><span class="n">save</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你只是要 update 少量欄位，而且資料處於離線狀態，可以使用 <a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html">Transactions</a> 搭配 find_in_batches，做完兩千筆再一次 commit，而不是每次做完就 commit 一次，在資料量很大的狀況下也可以節省不少時間。</p>

<h3>5. 使用 update_column / sneacky-save 而非原生 save</h3>

<p>用原生 <code>save</code> 會有什麼問題呢？原生的 <code>save</code> 在資料儲存時，會經過一堆 <code>validator</code> 和 <code>callbacks</code>，即使你只是要簡單 update 一個欄位，會觸發到一狗票東西（假設 10 道 hook），那 10 萬筆就是過 100 萬道 hook 了啊。天啊 /_\，機器死掉不意外。</p>

<p>如果你想要閃掉 hook 的話，可以使用 update_column，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class='line'>  <span class="n">post</span><span class="o">.</span><span class="n">update_column</span><span class="p">(</span><span class="ss">:board</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="n">post</span><span class="o">.</span><span class="n">save</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>但 update_column 的缺點是一次只能 update 一個欄位，如果你有 update 多個欄位的需求，可以用<a href="https://github.com/partyearth/sneaky-save">sneacky-save</a> 這套 gem。</p>

<p>如其名，sneacky-save 偷偷儲存不會勾動任何天雷地火。</p>

<h3>6. 可以的話使用 Post.select(&#8220;column 1, colum2&#8221;).where</h3>

<p>很多人會忽略一件事，<code>Post.where("id &lt; 10")</code>，其實是把這 10 個 object 拉出 database。Post 裡面有什麼呢？會有幾千字的 <code>content</code> 啊。所以當你下了這道 comment 後，拉出來的是這些內容</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span> <span class="no">Load</span> <span class="p">(</span><span class="mi">18</span><span class="o">.</span><span class="mi">8</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="sb">`posts`</span><span class="o">.</span><span class="n">*</span> <span class="no">FROM</span> <span class="sb">`posts`</span> <span class="no">WHERE</span> <span class="p">(</span><span class="nb">id</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>拉出 10 萬筆會發生什麼事呢？(炸)</p>

<p>所以這也是我建議如果你沒有複雜操作（相依高度 model 邏輯）需要的話，千萬別碰 ActiveRecord，因為你不會知道會按下哪一顆核彈按鈕。</p>

<h3>7. 使用 delegate 把大資料搬出去</h3>

<p>ActiveRecord 裡面有 delegate 這個 API。如果你嫌要 <code>Post.select("column 1, colum2").where</code> 這樣東閃西閃很麻煩，還是希望使用 <code>SELECT post.*</code>。那麼不妨可以換一個思路，把肥的 column 丟到另外一個 table，再用 delegate 接起來。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">has_one</span> <span class="ss">:meta</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">after_create</span> <span class="ss">:create_meta</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">deleage</span> <span class="ss">:content</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:meta</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>8. 操作資料前，別忘記打 INDEX</h3>

<p>舉凡操作資料，多半是至少會先下個 condition。再看是直接用 SQL 處理掉還是跑迴圈。不過一般開發者最會中地雷的部分就是</p>

<ul>
<li>忘記打 index</li>
</ul>


<p>忘記打 index 下 condition ，就會引發 table scan，這當然會很慢啊 /_\</p>

<ul>
<li>對 varchar(255) 直接打 index</li>
</ul>


<p>使用 Rails 產生的 varchar，多半是 varchar(255)，很少有人會直接去改長度的。而且使用 Rails 直接打的 index，也就是全長的 index 打下去了。效率爛到炸掉。</p>

<p>可以用這招 <a href="http://blog.gslin.org/archives/2012/07/17/2911/%e5%b0%8d-mysql-%e7%9a%84-varchar-%e6%ac%84%e4%bd%8d%e4%bd%bf%e7%94%a8-index-%e6%99%82%e5%8f%af%e4%bb%a5%e5%a2%9e%e5%8a%a0%e6%95%88%e7%8e%87%e7%9a%84%e6%96%b9%e6%b3%95/">index 可以指定只取前面 n chars</a> 的方式增進效率</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ALTER</span> <span class="no">TABLE</span> <span class="n">post</span> <span class="no">DROP</span> <span class="no">INDEX</span> <span class="no">PTitle</span><span class="p">,</span> <span class="no">ADD</span> <span class="no">INDEX</span><span class="p">(</span><span class="no">PTitle</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>Percona 前幾天也有一個 talk 是 <a href="http://www.percona.tv/percona-webinars/mysql-indexing-best-practices">MySQL Indexing Best Practices</a>，值得參考。</p>

<h3>9.  delete / destroy，刪除很昂貴。確保你知道自己在幹什麼。</h3>

<p>首先第一件事要分清楚 delete 和 destroy 有什麼不同。</p>

<ul>
<li>destroy 刪除資料並 go through callbacks</li>
<li>delete 刪除資料，不過任何 callbacks</li>
</ul>


<p>所以要刪除資料前，請確認你用的是何種「刪除」。</p>

<p>destroy_all 和 delete_all 也是類似的原則。</p>

<ul>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/destroy_all/class">destroy_all</a></li>
</ul>


<p>找到符合特徵的紀錄，然後呼叫 destroy method。在這個動作中會引發 <code>callbacks</code> ….orz</p>

<ul>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/delete_all/class">deletea_all</a></li>
</ul>


<p>找到符合特徵的紀錄，刪掉，但不觸發 <code>callbacks</code>。</p>

<p>不過如果你真的要「清空 DB」。不要用 delete_all，MySQL 提供了：TRUNCATE 給你用。請用這個&#8230;</p>

<ul>
<li>TRUNCATE TABLE</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;TRUNCATE TABLE </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>雖然 delete 不觸發 callbacks，但是「刪除」DELETE 真的很慢，因為
DELETE 涉及到會 update index，所以會…很慢。<a href="http://stackoverflow.com/questions/4020240/in-mysql-is-it-faster-to-delete-and-then-insert-or-is-it-faster-to-update-exist">http://stackoverflow.com/questions/4020240/in-mysql-is-it-faster-to-delete-and-then-insert-or-is-it-faster-to-update-exist</a></p>

<p>如果你的資料要作大量的刪除動作，有兩種思路可以繞。</p>

<p>一個是使用軟性刪除 soft_delete，也就是加上標記標示已刪除，但實質上不從資料庫刪除資料，只 update 會比 delete 快一點。有 <a href="https://github.com/winton/acts_as_archive">acts_as_archive</a> 可以用。</p>

<p>另外一個想法是：與其用刪的 (DELETE) 不如用 塞的 (INSERT)</p>

<p>開一個新的 Table，用倒的，把 match 的 record 塞到新的 DB 去。INSERT 比 DELETE 快太多了。</p>

<h3>10. 無法避免的昂貴操作丟到 background job 去操作。</h3>

<p>使用 <code>posts.each</code> 是一個昂貴的線性操作。這個 process 會無限的膨脹及 block 資源。</p>

<p>所以可以改用一個作法，使用 background job 如</p>

<ul>
<li><a href="https://github.com/collectiveidea/delayed_job">delayed_job</a> (不推薦)</li>
<li><a href="https://github.com/defunkt/resque/">resque</a></li>
<li><a href="http://mperham.github.com/sidekiq/">sidekiq</a></li>
</ul>


<p>把昂貴的操作包成獨立事件。塞進 queue 裡面，丟到背景跑，然後開 10 支 worker，十箭其發，速度可以快不少。</p>

<p>之所以把 delayed_job 列出來又不推薦的原因是因為 delayed_job 清 queue 的方式是用 DELETE，在第九點我們談過了，在有大量資料的情況下，「刪除」這件事會非常昂貴。使用 delayed_job 無異是拿汽油澆火。</p>

<h2>結論</h2>

<p>十點列下來。我的建議是，如果你手上的資料量大到一個程度，能儘量回歸基本(SQL command)就回歸基本。因為使用 ActiveRecord ，開發者永遠不知道自己什麼時候會按下核爆彈的按鈕啊…</p>

<h4>其他</h4>

<p>目前我們固定在禮拜二，都會在 松江路的田中園 上舉辦 <a href="http://www.meetup.com/taipei-rails-meetup/">Taipei Rails Meetup</a>。我自己本身也會固定在這裡免費幫大家解答 Rails 與 Web Operation 相關的問題。而坦白說，最近一些比較經典的 Post 也是從聚會裡的問答集裡面萃取出來的。</p>

<p>如果你對 Rails 有濃厚的興趣又住在台北，歡迎每週加入我們，謝謝！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Startup 別「找人」來上班，請「徵人」來上班]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/18/recruiting-team-member/"/>
    <updated>2012-08-18T13:05:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/18/recruiting-team-member</id>
    <content type="html"><![CDATA[<p>朋友的公司最近遇到一些公司成長上的問題。這些問題搞的他很頭大，於是也請我幫他想想辦法。看問題到底是出在哪裡…</p>

<p>公司裡面的員工，在當初面試時都沒什麼異狀，但進來之後有一些工作上的問題搞得他頭很大。</p>

<p>原因是有些人的職能明顯有落差（也就是當初面試進來時，是希望他補上這個工作的缺乏產能，但本身技能在進入這個團隊，跟著運轉時跟不上）。而他在幫忙修正 Coach 這些同事時，發現了一個大問題。</p>

<p>有人被指正一講就聽，馬上有顯著的進步。有些同事卻出現明顯的認知落差，明明知道自己已經出問題了，卻還是想要照自己的那一套「發揮」。類似的「發揮」病，也出現在一些菜鳥身上。菜鳥很明顯的基本功夫打沒打穩、團隊目標也沒摸清楚，就想要自作主張的改一些方向，造成白工。老是挑一些不是問題的問題反應，希望反應證明自己的才能。就算被電了，過沒多久還是會重複發生同樣的事情…</p>

<p>「發揮」病讓他一個頭兩個大。希望我幫他把脈解決…</p>

<p>本來這是別人的事情，加上這種事情其實在大公司也時常發生（以前我也遇過&#8230;），所以我也隨口安慰他：「這些事情本來就會遇到，不是你特別倒楣啦&#8230;」想要打發掉他 XD</p>

<p>他還是一直拜託我幫他找問題，因為這個問題讓他很痛。再來是，這些同事都是他「找進來」的&#8230;，要是真的救不起來，在「處理」上會非常麻煩…</p>

<h3>共同特徵：「發揮病」</h3>

<p>聽到「找進來」這個關鍵字，讓我燃起了興趣。於是我就追問他更多詳細的關鍵，員工組成成分…</p>

<p>然後才發現這些「發揮病」的患者有一件共同的驚人特徵，那就是他們真的都是「被從外面找進來的」。都是他透過「私人關係」從外面找來的「朋友」或「熟人」。</p>

<p>OK。找到問題了。Hiring 101：「千萬不要找朋友來當同事，否則通常出差錯了以後 90% 機率連朋友都做不成。而且很多朋友，是只有當朋友的本事而已，技術和職場相處上能不能當同事很難說。」</p>

<p>但是他反駁，當中這些人的技術或潛質是他自己驗證過，也算很不錯的。但進來之後不知為什麼也禁不起考驗。而且不約而同的，「發揮病」很嚴重。個人喜好隱隱約約的似乎遠遠重於團體目標…</p>

<p>「反而」那些是從網路上應徵來的員工，或自己主動投遞履歷進來工作的，幾乎都沒有這種問題。個個都是積極學習，主動了解團隊目標，樂於修正成長的好夥伴。</p>

<p>他很懊惱的抱怨，他不是不願意讓人「發揮」的 Leader，只是部分這些同事的「角色」，第一優先的不是發揮，而是「打穩基礎」（紮實做好手頭工作補上團隊缺乏產能，了解共同目標）。達到了，才能談所謂的「發揮」啊？</p>

<p>為什麼這些人不能學學那些正常的同事呢？</p>

<h3>不是每一個人的位子上面都有「客卿」標籤</h3>

<p>聽到這裡，我腦袋快速倒轉過幾遍以前遇過的 case。大概知道這個團隊出了什麼問題了。（其實斷斷續續也討論了不少次，一點一點拼起來&#8230;）</p>

<p>最根本原因就在於所謂的「客卿心態」。</p>

<p>別誤會，「客卿」並不是不好的詞。</p>

<p>「找來的人」之所以跟那些「主動應徵」的人，其根本心態不同點就在於，他是被「找來」的。既然是被「找來」的就是要來「發揮所長」的，這些同事認為他是「卿」。</p>

<p>這就造成美麗的誤會。有時候，公司「找」員工，並不一定是要找他「發揮」，而是要缺一個位子，希望「找合適技能的人」來補上這個位子「貢獻」。</p>

<p>所謂能夠讓人「發揮」的位子，多半是個獨立的職缺，或者是組織主管的位置。而讓人「發揮」的位子，身為主管，多半也會先幫他掃除一些障礙，比如說先跟團隊成員提醒這位是新主管，請大家多多配合。或者是這位新同事，有特殊的才能，但做事也有自己獨特的規矩…etc.（讓他融入團隊時比較順暢）</p>

<p>但是如果只是一個一般的職缺，公司怎麼可能特別為這個位子特別作這些事。但問題是，被「找來」的同事不會這麼想，他會認為他是來「發揮」的，也就是在一開始就會跟那些主動來應徵的人心態上就有根本的不同，潛意識上他的優先權不會是先去管別人的 rule 是什麼，甚至還會產生自己是卿所以自己比較厲害的心態，認為新同事應該「讓」他。</p>

<p>他自己會趕快想把私人壓箱寶拿出來，「作一些事」。然後就造成悲劇了…</p>

<p>當然，能夠發現自己有錯誤心態而趕快修正的人，不是沒有，而是相對比例並沒有那麼多…</p>

<p>延伸閱讀：<a href="http://blog.xdite.net/posts/2012/05/13/the-startup-owners-manual-02/">The Startup Owner&#8217;s Manual 讀書心得（2）: New-product Introduction Model 致命的九宗罪</a> # 7. Sales and Marketing Execute to a Plan</p>

<p>相反地，來應徵的人或主動投遞，就通常沒有這一狗票問題。因為這些同事的出發點，是來「加入一個他想要工作的團隊」的。他們通常會假設這個團隊已經有自己獨立運作的一套 rule 了。他會想要先搞清楚這個 rule 在哪裡，如何將自己 fit in。而不是讓團隊來 fit in 他…</p>

<h3>小結</h3>

<p>Startup 最珍貴的資產就是同心一致的團隊，最害怕的是搞不清楚狀況的團隊成員各行其是…</p>

<p>不少 Startup 團隊在一開始草創時，缺乏自信或管道，找到戰力。因此都會想透過熟悉的渠徑「找」到人補上空缺，繼續往目標前進。</p>

<p>只是現在看起來，這個「找」，看起來還是要好好的看狀況使用啊…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL Indexing Best Practices]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/16/mysql-index-best-practice/"/>
    <updated>2012-08-16T03:19:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/16/mysql-index-best-practice</id>
    <content type="html"><![CDATA[<p>睡前看到 <a href="http://blog.gslin.org">DK</a> 在 twitter 講 Percona 有一場 Webniar 在講 MySQL index 的 best practices。</p>

<p>結果連過去看時發現已經結束了。不過還是不死心的註冊了一下…</p>

<p>大概半小時後系統通知影片和 slide 在 <a href="http://percona.tv">http://percona.tv</a> 已經可以抓了…</p>

<ul>
<li>MySQL Indexing Best Practices: <a href="http://www.percona.tv/percona-webinars/mysql-indexing-best-practices">影片連結</a>、<a href="http://www.percona.com/files/presentations/WEBINAR-MySQL-Indexing-Best-Practices.pdf">投影片連結</a></li>
</ul>


<p>內容講的蠻紮實。教了不少讓開發者判斷 Index 如何下、下得好不好的準則…</p>

<p>有時間應該整理成講義的…</p>

<p>===</p>

<p>打完這篇要去睡之前，又在 twitter 上看到 confreaks 丟出了新的 pry 影片 <a href="http://confreaks.com/videos/959-mwrc2012-prying-into-your-app-s-private-life">http://confreaks.com/videos/959-mwrc2012-prying-into-your-app-s-private-life</a>。（前幾天寫過的 <a href="http://blog.xdite.net/posts/2012/08/12/pry-the-new-debugger/">Pry ：新一代 Debug 利器</a> )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pry ：新一代 Debug 利器]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/12/pry-the-new-debugger/"/>
    <updated>2012-08-12T18:37:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/12/pry-the-new-debugger</id>
    <content type="html"><![CDATA[<p>提起 <a href="https://github.com/pry/pry">Pry</a>，一般 Ruby 開發者幾乎對這套 Gem 沒有很深的印象。比較有在追社群新聞的人，會知道這是一套新的 IRB 取代方案，但僅此於如此。事實上在近一年前，<a href="http://ruby5.envylabs.com/episodes/173-episode-170-april-26-2011/stories/1526-pry-a-powerful-alternative-to-the-standard-irb-shell-for-ruby">Pry 被 Ruby5 報導的原因</a> 也是因為很炫的 console。</p>

<p>比如說 Pry 允許開發者在 console 這樣幹：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pry(main)&gt; cd Article
</span><span class='line'>pry(#&lt;Class:0x1022f60e0&gt;):1&gt; self
</span><span class='line'>=&gt; Article(id: integer, name: string, content: text, created_at: datetime, updated_at: datetime, published_at: datetime)</span></code></pre></td></tr></table></div></figure>


<p><code>Article.first</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pry(#&lt;Class:0x1022f60e0&gt;):1&gt; first
</span><span class='line'>=&gt; #&lt;Article id: 1, name: "What is Music", content: "Music is an art form in which the medium is sound o...", created_at: "2011-08-24 20:35:29", updated_at: "2011-08-24 20:37:22", published_at: "2011-05-13 23:00:00"&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>cd name</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pry(#&lt;Article:0x102300c98&gt;):2&gt; cd name
</span><span class='line'>pry("What is Music"):3&gt; upcase
</span><span class='line'>=&gt; "WHAT IS MUSIC"</span></code></pre></td></tr></table></div></figure>


<p>允許了開發者利用 console 進行程式的進階探索。當然這樣的 feature 是很炫。但是不算很大幅解決了開發者的問題，所以只被當作是一套還不錯的 shell。就這麼被大家靜悄悄的撇在身後了…</p>

<h3>killer feature: binding.pry</h3>

<p>但是大家比較沒有注意到的是，Pry 真正強大的地方不在於它的 console，而是在後面接著演化出的 <code>binding.pry</code>。</p>

<p><code>binding.pry</code> 做的是 Runtime invocation。也就是可以在執行時攔截呼叫。這樣講你可能沒有感覺。</p>

<p>真正厲害的用途是： 例如搭配 Rails 使用，在程式碼裡面插入 binding.pry。打開 <code>rails s</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">CourseController</span> <span class="o">&lt;</span> <span class="no">ApplcationController</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>    <span class="vi">@course</span> <span class="o">=</span> <span class="no">Course</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">binding</span><span class="o">.</span><span class="n">pry</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>當 browser 打開 <a href="http://localhost:3000/courses/30">http://localhost:3000/courses/30</a>，pry 會自動攔下 request，跳出 console 供開發者 debug 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">From</span><span class="p">:</span><span class="sr"> /Users/x</span><span class="n">dite</span><span class="o">/</span><span class="no">Dropbox</span><span class="o">/</span><span class="n">projects</span><span class="o">/</span><span class="n">mentorhub</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">controllers</span><span class="o">/</span><span class="n">courses_controller</span><span class="o">.</span><span class="n">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">20</span> <span class="no">CoursesController</span><span class="c1">#show:</span>
</span><span class='line'>
</span><span class='line'>    <span class="mi">20</span><span class="p">:</span> <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>    <span class="mi">21</span><span class="p">:</span>   <span class="vi">@course</span> <span class="o">=</span> <span class="no">Course</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="mi">22</span><span class="p">:</span>   <span class="nb">binding</span><span class="o">.</span><span class="n">pry</span>
</span><span class='line'>    <span class="mi">23</span><span class="p">:</span> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>開發者可以在 console 直接就拉出 @course 這個 object 出來看</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="c1">#&lt;CoursesController&gt;)&gt; @course</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;Course id: 30, name: &quot;voluptas&quot;, user_id: 1, course_topic_id: 2, plan: &quot;Laboriosam labore soluta debitis excepturi consequa...&quot;, hourly_rate: 822, location: &quot;Taipei&quot;, course_type: nil, created_at: &quot;2012-08-12 09:41:21&quot;, updated_at: &quot;2012-08-12 09:41:21&quot;, video_link: nil, video_link_html: nil&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以繼續追下去看裡面的東西</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="c1">#&lt;CoursesController&gt;)&gt; cd @course</span>
</span><span class='line'><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="c1">#&lt;Course&gt;):1&gt; plan</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="s2">&quot;Laboriosam labore soluta debitis excepturi consequatur et eos et et praesentium doloremque. qui debitis ab est rerum aut velit fuga ut nemo omnis eum praesentium voluptatem ut. eum fugit rerum fuga error architecto quod nesciunt assumenda in. dicta &quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>binding.pry</code> 可以 Runtime 攔截呼叫物件，這讓開發者在寫一些複雜 Library 或者是 API 交涉資訊時，頓時就變得如虎添翼。因為每次在解決這類需求時，狀況都很像被綁黑布蒙著眼開發，最討厭的就是每次還要不斷的執行「印出」 debug，效率低落的驚人。</p>

<h3>pry-nav</h3>

<p>也因為 <code>binding.pry</code> 太好用。社群也基於 Pry 繼續做了其他的 pry 的 plugin。最 killling 的就是 <a href="https://github.com/nixme/pry-nav">pry-nav</a>。</p>

<p>pry-nav 做的就是可以讓你在 <code>binding.pry</code> 的攔節點前後，作 <code>next</code>、<code>step</code>。直接一行一行的逐一 debug。</p>

<p>相信我，如果你在寫通訊交涉的 Library，或者是正在改複雜的 Rails View。用到 pry + pry-nav 鐵定會感動到哭出來 XD</p>

<h3>pry-remote</h3>

<p>Pry 搭配 Rails，在往常的作法只有 <code>rails s</code> 可以叫出 debug console 而已。但很多人實際上是使用 <a href="http://pow.cx">Pow</a> 作為開發用 HTTP Server。</p>

<p>這樣的需求可以用 <a href="https://github.com/Mon-Ouie/pry-remote">pry-remote</a> 解決。pry-remote 的作法是把原本的 <code>bindig.pry</code> 改成 <code>binding.remote_pry</code>。</p>

<p>而 <code>binding.remote_pry</code> 會開一支 DRb 起來，開發者再用 <code>pry-remote</code> 連到 debug console。</p>

<h2>小結</h2>

<p>Pry 在短短一年間，已經默默的演化出一個龐大的生態圈，只是這當中的過程並沒有大張旗鼓，所以很多開發者並沒有發現 Pry 其實已經默默從 console shell 進化到超強 Debugger 了。</p>

<p><a href="https://github.com/pry/pry/wiki">Pry 的 wiki</a> 上有著相當大的相關資源，相當值得各位繼續探索下去…</p>

<h3>同場加映</h3>

<p><a href="https://github.com/mrbrdo/rack-webconsole">rack-webconsole</a> 一樣是 pry 的應用，可以在 webpage 裡面直接開 console 改東西…超酷的</p>

<h3>追加</h3>

<p>Confreaks 最近又釋出了 Moutain West Ruby conf 的 Pry talk <a href="http://confreaks.com/videos/959-mwrc2012-prying-into-your-app-s-private-life">http://confreaks.com/videos/959-mwrc2012-prying-into-your-app-s-private-life</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「創業」不是一個目的地]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/12/startup-is-not-a-destination/"/>
    <updated>2012-08-12T06:07:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/12/startup-is-not-a-destination</id>
    <content type="html"><![CDATA[<p>自己出來創業，轉眼間也快半年了。蒙各界賞光，<a href="http://rocodev.com">公司</a>的生意算是不錯。目前也跟生意夥伴 Max 合作得很開心。<a href="http://maxlu.cc">Max</a> 是個天生的生意人和創業家，我們常談論很多關於創業的點點滴滴，從這過程中激盪出不少智慧…</p>

<p>最近跟他一個討論的話題，就是台灣這麼多人在網路創業，尤其是台灣也存在著不少 質優的 developer，但為什麼所謂的網路創業為什麼都「不算成功」或甚至失敗得很徹底。</p>

<p>因為我也在創業的這條路上，這一兩年來我一直在思考這件事情，到底問題在哪裡？</p>

<p>一直到最近的這幾個禮拜我大概理出一個頭緒：原因是太多人把「創業」當作是一個「目的地」，而不是一個職業、解決問題的過程，為想創業而創業，所以所謂的失敗率才這麼高&#8230;。</p>

<p>我知道這樣的結論可能會招致很多反對的炮火聲，但請先耐著性子繼續讓我把最近歸結出的想法說完：</p>

<h3>「上班」到「創業」不是一個「打怪」「升等」路線</h3>

<p>這一個想法是從 <a href="http://www.businessweekly.com.tw/blog/article.php?id=1838">給下個年輕世代的殘酷真相</a>得出來的靈感。這篇文章有一段是關於年輕人對於未來的憧憬：</p>

<p>「22到24歲時念個好的研究所。在25歲左右開始第一份工作然後住自己租的公寓。順利的話我想要在28歲左右自己開公司，大約30歲左右結婚。我想我多數的同學和我在財務上想像我們能夠在28歲時擁有自己的車子，30歲時開始存錢準備有天能夠買自己的房子。」</p>

<p>如果你已經出過社會幾年了，就會知道這真的如同原文作者鐘先生所說的，是一個非常天真的夢。而在這個年代，你可能很難在 30 歲前達到這樣的夢想。這卻是這個世代普遍受過大學教育年輕人所共同的夢。</p>

<p>而這段話也意外彰顯出一個迷思：「受一個不錯的教育，預備找到一個好的工作。工作一段時間，升到不錯的職位得到不錯職業的薪水，最後創業達到財務自由。」</p>

<p>yes。「最後」「創業」</p>

<p>我們把從上班到創業當成是一個「打怪」「升等」路線，問題是真實生活卻不是這麼回事。</p>

<h3>「上班」的終點不是「創業」</h3>

<p>「上班」的終點不是「創業」。這是我最後思索驗證出來的結論。（雖然乍看之下好像是廢話）</p>

<p>我一直以來有一個謎團未解：為什麼有人「沒什麼技術」創業卻會成功，有人功夫不錯，為什麼創業卻會去失敗？</p>

<p>我想這也是大部分創業者共同的疑惑。幾年來我一直思考，但沒有答案。</p>

<p>直到最近才意外的在一本書裡面得到了一個比較可靠的模型，找出了一點頭緒，這本書的書名是：<a href="http://www.books.com.tw/exep/prod/booksfile.php?item=0010546972">川普、清崎點石成金</a>。</p>

<p>清崎由一個模型為這個問題做出了解釋：它把所有人分成四種類型：</p>

<ul>
<li>Employee（受僱者、僱員）：為他人工作而賺取薪金，追求安全、穩定，畏懼風險的一群。</li>
<li>Self-employed（自僱者、專業技能者、自由職業者、小企業主）：擁有某一專長而能為自己工作而賺錢，重視完美，不輕易將職責交託予人，如：醫生、律師‧‧‧等等。</li>
<li>Business owner（企業所有人、僱傭者、僱主、老闆）：擁有一個能夠良好運轉的企業系統，視風險為挑戰、歡迎問題並樂於透過解決問題而致富的一群，信奉以別人的時間(OTHER PEOPLE&#8217;S TIME，OPT)以及別人的金錢(OTHER PEOPLE&#8217;S MONEY，OPM)為他們工作，收入來源是企業的收益。</li>
<li>Investor（投資者）：讓錢為他們工作，收入來源是各種投資，用錢來產生出更多的錢，即是「富爸爸」一書中所強調「讓金錢為你工作」。</li>
</ul>


<p>在這本書中，他指出世界上最有錢的人都是 B。（而非大家以為的 I ）</p>

<p>且清崎認為，身處 E、S兩種象限，無法令自己達至財務自由。我們應該透過成為B、I象限，才能達到目標。</p>

<p>無可厚非的大家都想要變成 B，或變成 I 。但有幾種身分轉變模式，很容易失敗，分別是（E -> I , E -> B , I -> B )。而比較容易成功的是 ( S -> B ) 或者是 ( B -> I )。</p>

<p>為什麼一些創業者，創業不久後會瞬間就 fail 是因為他們往往在 E 階段，就直接想往 B 階段跨過去，缺乏太多存活的技巧，所以就直接陣亡。清崎建議的路線是，如果你想成功的話，採取 (E -> S -> B) 的路線，機率是會比較高的。</p>

<p>這個模型解答一些疑惑（為什麼有人快速陣亡），但卻沒有回答到另外一些問題：為什麼有人直接走 E -> B 或甚至直接 B 卻成功了。</p>

<h3>「解決問題」然後才「創業」</h3>

<p>Max 就是典型的例子，他是直接就當 B 的人（還有一些創業成功的網路界朋友是 E-> B）。E -> B 成功不是不可能。那麼關鍵點在哪裡？Max 不會寫 code，但他事業成功了。我也問了 Max，Max 只跟我說了他「解決了問題」，「也許應該是這樣」。</p>

<p>很多創業文章的重點，都是勸創業者實際「踏出辦公室」「實際解決問題」。這些文章的道理是不錯，總是令我覺得說不出的哪裡怪。</p>

<p>最近還有一篇文章 <a href="http://www.alibuybuy.com/posts/74638.html">互連網創業降級論</a>。也是說不出的詭異。</p>

<p>後來我終於想清楚所謂邏輯的謬誤在哪裡。所謂的「創業」應該是創業者有一個問題，創業者為了解決它，而製造了方法，最後重新將此方法規模化，乃所謂「創造一個事業」。而目前的網路創業很多卻是所謂的「創業者」手上擁有了一堆技術，然後到處找問題，想把這些「技巧」變成「解決的方法」。難怪失敗率很高。</p>

<p>因為創業者不是真真切切擁有一個「很痛的」問題，然後製造一個方法解決它。而是賭自己的方法「能夠找到一個問題而恰好」解決它。能夠賭中的機會已經夠低了。而碰上這個「問題」恰巧「很痛」的機會又更低，這個問題不夠痛，造成利潤追不上成本，最後虧本。</p>

<p>這就解釋了為什麼那些「沒有技術」的人為什麼能夠網路創業成功，他們並非所謂的幸運。因為他們並非「沒有技術」，他們擁有珍貴的「解決問題的 Domain Knowledge」和其他建構事業所需的綜合技能（如 Leadership, Finace, Accounting, Sales)，缺的是「網站建構技術」。但這不會阻止他們成為 B。因為這樣東西可以用資本買到，品質的高低並不會太大方面影響到能夠解決問題的核心能力。</p>

<p>而只有「網站建構技術」，卻無法單獨自己形成一個生意。因為這項技術並沒有解決任何問題。（除非你的事業就是販售前者製作好的網站或者是使用這些技術解決同領域的問題）</p>

<p>所謂的 ESBI 模型，缺陷的部分就在於：對於 S 的解釋過於單薄。癥結點在於若創業者的 S 與 B 的「領域」並不是同一個的話，S -> B 的成功機率是很低的。</p>

<p>這也解釋了為什麼很多網路創業最終以失敗收場。因為這些 S 者，專精的領域是軟體、行銷，而非 Bussiness Domain。而那些成功的 B 者，並非幸運，而是因為他們都是該領域的 solution provider。</p>

<h3>小結</h3>

<p>繞了這麼遠，才終於把這套想法梳理成一個脈絡。為什麼清崎的建議是走 E -> S -> B。這是因為不一定有人可以一次走 B 就能成功。而作為一個 B，所需要的技能也並不僅只於單一方面的技術純熟就可以達成。所以走 E -> S -> B 是一個可靠的路線。但這絕不保證你走了 E -> S，就能到 B。</p>

<p>而要成為所謂的 B ，重點也不在於之前累計多少技巧，而是在「解決核心問題」的能力。「解決問題」，然後最後會變成「創業」，然後就會得到「超額回報」。</p>

<p>但是為了有一個生意而去製造一個生意，而不是把精力放在解決問題之上，通常結局不是失敗就是繞了超長的遠路&#8230;.</p>

<p>終於或多或少了解了一些這樣的來龍去脈&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strong Parameter: Mass Assignment 機制的防彈衣]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/12/strong-parameter-mass-assignment-solution/"/>
    <updated>2012-08-12T02:16:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/12/strong-parameter-mass-assignment-solution</id>
    <content type="html"><![CDATA[<p>還記得年初才發生的 <a href="http://blog.xdite.net/posts/2012/03/05/github-hacked-rails-security/">Github 被入侵事件</a> 嗎？</p>

<p>事件的起因是因為 Rails 內建的 mass assignment 機制，很容易被有心人利用這個漏洞入侵。</p>

<p>原本的 attr_accessible / attr_protected 的設計並不足夠實務使用。在該事件發生後，Rails 核心團隊在 3.2.3 之後的版本，預設都開啟了 <code>config.whitelist_attributes = true</code> 的選項。</p>

<p>也就是專案自動會對所有的 model 都自動開啟白名單模式，你必須手動對每一個 model 都加上 attr_accessible。這樣表單送值才會有辦法運作。</p>

<p>這樣的舉動好處是：「夠安全」，能強迫開發者在設計表單時記得審核 model 該欄位是否適用於 mass-assign。</p>

<p>但這樣的機制也引發開發者「不實用」「找麻煩」的議論。</p>

<h3>問題 1: 新手容易踩中地雷</h3>

<p>首先最麻煩的當然是，新手會被這一行設定整到。新手不知道此機制為何而來，出了問題也不知道如何關掉這個設定。更麻煩的是撰寫新手教學的人，必須又花上一大篇幅（就如同倒楣的我，想要幫 Rails 101 改版，結果內容無限追加）解釋 mass-assignment 的設計機制，為何重要，為何新手需要重視…etc.</p>

<h3>問題 2: 不實用</h3>

<p>手動一個一個加上 attr_accessible 真的很煩人，因為這也表示，若新增一個欄位，開發者也要手動去加上 attr_accessible，否則很可能在某些表單直接出現異常現象。</p>

<p>而最麻煩的還是，其實 attr_accessible 不敷使用，因為一個系統通常存在不只一種角色，普通使用與 Admin 需要的 mass-assignment 範圍絕對不盡相同。</p>

<p>雖然 Rails 在 3.1 加入了 <a href="http://enlightsolutions.com/articles/whats-new-in-edge-scoped-mass-assignment-in-rails-3-1">scoped mass assignment</a>。但這也只能算是 model 方面的解決手法。</p>

<p>一旦系統內有更多其他流程需求，scoped mass assignment 的設計頓時就不夠解決問題了…</p>

<h3>癥結點：欄位核准與否應該由 controller 管理，而非 model</h3>

<p>大家戰了一陣子，終於收斂出一個結論。原來一切的癥結點在於之前的想法都錯了，欄位核准與否應該由 controller 決定。因為「流程需求」本來就應該作在 controller 裡面。wycats 當時也起草了一份<a href="https://gist.github.com/1974187">解法的 proposal</a>。日後打算以 plugin 方式釋出。</p>

<h3>plugin：strong_parameter</h3>

<p>現在 plugin 出來了。（其實出來很久了，只是我一直沒寫文章&#8230;) 就是 <a href="https://github.com/rails/strong_parameters/">strong_parameters</a> 。strong_parameters 的想法與 DHH <a href="https://gist.github.com/1975644">當時扔出來的想法</a> 相近。</p>

<p>DHH 當時的作法</p>

<div><script src='https://gist.github.com/1975644.js?file='></script>
<noscript><pre><code>class PostsController &lt; ActionController::Base
  def create
    Post.create(post_params)
  end
  
  def update
    Post.find(params[:id]).update_attributes!(post_params)
  end

  private
    def post_params
      params[:post].slice(:title, :content)
    end
end</code></pre></noscript></div>


<p>是使用 slice 去把真正需要的部分切出來，所以就算 hacker 打算送其他 parameter 也會被過濾掉(不會有 exception)。</p>

<p>而 strong_parameters 的作法是必須過一段 permit，允許欄位。如果送不允許的欄位進來，會 throw exception。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">PeopleController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">update</span>
</span><span class='line'>    <span class="n">person</span><span class="o">.</span><span class="n">update_attributes!</span><span class="p">(</span><span class="n">person_params</span><span class="p">)</span>
</span><span class='line'>    <span class="n">redirect_to</span> <span class="ss">:back</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">person_params</span>
</span><span class='line'>      <span class="n">params</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="ss">:person</span><span class="p">)</span><span class="o">.</span><span class="n">permit</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:age</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>安全多了，擴充性也比較大&#8230;</p>

<h3>進階用法</h3>

<p>當然，每一段 controller 都要來上這麼一段，有時候也挺煩人的。Railscast 也整理了一些<a href="http://railscasts.com/episodes/371-strong-parameters">進階招數</a>：</p>

<ul>
<li>Nested Attributes</li>
<li>Orgngized to Class</li>
</ul>


<p>大家可以研究看看…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[影集] 喚醒新聞界的良知 The Newsroom]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/09/recommended-the-newsroom/"/>
    <updated>2012-08-09T00:18:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/09/recommended-the-newsroom</id>
    <content type="html"><![CDATA[<p>今天要在這裡推薦一部影集：HBO 拍攝的關於新聞從業界的影集 The Newsroom 「新聞急先鋒」。</p>

<p>這部戲大概是在 6/24 左右才開始播的影集，原本是沒有去追的。直到幾天前有人作好了第一集開場的中文字幕，在 FB 流傳，因為氣勢過於震撼，所以才開始注意。</p>

<p>主角 Will McAvoy 是一個極受歡迎的新聞主播，專題 News Night 的風格溫和中立極受大眾喜愛。第一幕是 Will 參加西北大學的座談，一個女學生提問：為什麼美國是世界上最偉大的國家？」座談都在閑扯，直到 一個女學生提問：「為什麼美國是世界上最偉大的國家？」原本 Will 不想要得罪人，亂扯一些答案。但主持人不放過 Will，Will 就大爆炸開始…XD</p>

<p>看了就知道&#8230;.</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/tG8F6BeAER8" frameborder="0" allowfullscreen></iframe>


<p>這個開場影片很讓人讚嘆，於是我就開始去挖這一部影集剩下的部分和劇集背景：</p>

<p>Will McAvoy 在該次爆發事件之後，雖然當時說了真話（美國並不是世界上最偉大的國家，但&#8230;），但影視圈大家對避之唯恐不及。他的老闆 Charlie 趁事件爆發後他去度假時，幫他找了以前的 Partner 準備作新型態的節目。</p>

<p>原本 Will 以為他老闆弄來這個 Producer 是認為西北大學那件事是出包，所以弄出這招搞他。後來才知道 Charlie 是欣賞他，欣賞他那番話找回良知，希望找來一個幫手，讓 Will 的節目轉型，也跳脫收視率的包袱扭曲，去作真的「新聞」，以良知報導「真相」。走出一番新路。</p>

<p>對比國內新聞節目亂象（特別是最近的旺中天走路工事件），看到這套影集真的很感慨。</p>

<p>第一集這一段 clip 並不是目前七集中最令人震撼的片段，第三集開場的陳詞才真正精彩：</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/0_i9fw43Moo" frameborder="0" allowfullscreen></iframe>


<p>因為實在太喜歡這一段的台詞，於是摘錄字幕如下：</p>

<pre>
晚安 我是 Will McAvoy 
這裡是 New Night
剛剛撥出的影片是 Richard Clarke
小布希總統的反恐中心主任
於 2004 年 3 月 24 號在國會前作證的影像
美國人喜歡那一刻，我喜歡那一刻
成年人要敢於為失敗負責
所以，今天節目的開始，我將加入 Mr. Clarke 的行列
向美國群眾，為我們的失責而道歉

因為在我負責期間這個節目時，我並沒有能夠有效地向傳遞資訊和教育美國選民

讓我先聲明 我並不代表…所有的新聞工作者道歉 並不是所有新聞工作者都需要道歉 我僅代表自己

我是這一系列複雜、重複、無知，且尚未被糾正的失敗的幫兇

我所領導的行業，錯報選舉結果、誇大恐慌事件、挑起政治辯論、隱瞞國家結構的改變 從經濟危機到國力的真實水準

到我們面對的真正威脅。

我所領導的行業如Harry Houdini一般 (知名魔術大師)

嫻熟地分散你們的注意力，同時缺乏審慎地將成千上萬的勇敢年青人送上戰場

我們失敗的原因顯而易見：我們過分重視收視率。

在大眾通訊時代初始，新聞界的哥倫布和麥哲倫－William Paley和David Sarnoff (CBS之父及美國廣播通訊業之父) 

前往華盛頓，與國會簽署一份協議：

「國會允許初有雛形的電視台，免費使用屬於納稅人的廣播頻道， 

條件是這必須是公共服務，即每晚用一小時播報訊息， 

就是我們現在稱為晚間新聞的東西。」

國會未能預料到電視廣告對消費者的巨大影響， 

所以協議中沒有任何一條本能大大改善國家言論秩序的內容； 

國會忘了加上「在任何條件下，於新聞播報期間內都不能有付費廣告」，

他們忘了說「納稅人的廣播頻道是免費給你們使用， 

所以每天有23個小時，你們需要營利，但晚上那一小時，你們只能為國會服務」。

所以現在，那些絕對誠實的新聞人， 比如 Murror Reasoner 和 Huntley 還有
Brinkley 和 Buckley 和 Cronkite 和 Rather 和 Russert ...(皆為知名主播)

現在他們得和我這樣的人競爭

做為新聞主播面對的業界壓力，卻與澤西海岸（肥皂劇）製片人一模一樣 (收視率決定一切) 

那樣的方法對我們很有利，但本節目將不再這樣做。

你可能不相信，這個時代仍有一些偉大的新聞人，他們有卓越的頭腦跟多年的經驗， 和對新聞工作的真摯熱情

但現在他們只是少數人，當碰到馬戲團，他們變得無力競爭，被淹沒了...

我要辭掉馬戲團的工作，轉換隊伍，我要和那些被打擊的人站在一起，

他們仍有贏的信念 我很感動

我希望他們能使我受教。

從今天起，我們播出什麼新聞，如何呈現出來，

都只有一個簡單的原則：在民主制度中，沒有什麼比腦袋清楚的選民更為重要。

我們將努力將新聞放到更大的背景下，因為很少有新聞是獨立存在的；

我們將成為事實的承載者，成為那些含沙射影、投機炒作、言過其實，或胡言亂語的死對頭

我們不是餐廳服務員，只會用你喜歡的方式呈現你喜歡的新聞

我們也不是電腦，只會乾巴巴地說出事實；因為新聞只有在人文背景下才有用

我不會抑制我的個人觀點，但同時我也將不遺餘力展現出不同於我的觀點。

你也許會問，我們憑什麼做出這些決定？

我們是 Mackenzie MacHale 和 我自己

MacHale 是我們的執行製作人，他從超過百篇報導中整理出我們需要的資訊

他是製作人、分析師和技師。我們樂意提供他的資格證書。

我是這節目的總編輯，對於節目上出現的一切，我有最終決定權。

我們憑什麼作這這些決定？

我們是媒體中的菁英

稍後，我們將繼續播報新聞...」

</pre>


<p>非常非常深的反省。</p>

<p>The Newsroom 每一集處理的題材都很發人深省。不少題材的處理都可以讓你直接勾想起國內的媒體亂象。比如第四集在報導：眾議員Giffords被槍擊事件時。電視台高層一直施壓節目必須馬上報導 Giffords 已死亡（純屬謠言，只因其他台先報導，高層怕沒追到新聞會掉收視率），製作人卻力抗回了：「只有醫生才能宣告一個人死亡，新聞媒體不能」。那一個片段真的會讓看到起雞皮疙瘩。</p>

<p>看到第七集，集集都讓我嘆息，「這只是電視劇」。何時媒體才能夠醒過來與自清呢？</p>

<p>不過 The Newsroom 目前開播才七集，就已經掀起不小的震撼。我真的很推這部電視劇，希望更多人能看到這部影集，能重新思考新聞媒體的本質到底是什麼。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何乾淨的 使用 / 修改 Bootstrap Framework]]></title>
    <link href="http://blog.xdite.net/posts/2012/08/03/how-to-use-bootstrap-in-clean-way/"/>
    <updated>2012-08-03T20:41:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/08/03/how-to-use-bootstrap-in-clean-way</id>
    <content type="html"><![CDATA[<p><a href="http://twitter.github.com/bootstrap/">Bootstrap</a> 是 Twitter 推出的一套 CSS Framework。相當受歡迎的原因是因為讓原本對設計苦手的程式設計師在開發產品早期原型時可以有個可以看的門面先擋著。</p>

<p>又因為 Bootstrap 在 2.0 版以後加入了 configuable 以及 responsive 的設計。所以有些開發團隊，不僅只在 development 階段當臨時門面，在 production 階段，也作為骨架使用。</p>

<p>不過作為 production 使用，就出現了一個不容忽視的課題：如何在一套已經有現成的 styling 的 CSS Framework 上「客製發揮」。</p>

<p>「客製」往往意味著「大幅修改」。不過既然也要「乾淨」，這也表示一個附加條件：「不能破壞 bootstrap 原始架構」。</p>

<p>How can it be possible?</p>

<p>以下是我平常使用 bootstrap 的方式：</p>

<h3>利用 Bundler 掛上 Bootstrap 的 rubygems</h3>

<p>Bootstrap 的原始版本是使用 LESS 撰寫，不過也有開發者修改成 SCSS 版本。我本身是使用 anjlab 的 <a href="https://github.com/anjlab/bootstrap-rails">bootstrap-rails</a>。</p>

<p>透過 Gemfile 把 Bootstrap 掛上來，不直接放進 Rails project 裡面。</p>

<figure class='code'><figcaption><span>Gemfile</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="s2">&quot;bootstra-rails&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>利用 Asset Pipeline 以及 SCSS 機制，客製、覆寫</h3>

<h4>application.css 內容</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="o">//=</span> <span class="nt">require</span> <span class="nt">base</span>
</span></code></pre></td></tr></table></div></figure>


<h4>base.scss 內容</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scss'><span class='line'><span class="k">@import</span> <span class="s2">&quot;bootstrap-config&quot;</span><span class="p">;</span>
</span><span class='line'><span class="k">@import</span> <span class="s2">&quot;bootstrap&quot;</span><span class="p">;</span>
</span><span class='line'><span class="k">@import</span> <span class="s2">&quot;bootstrap-customized&quot;</span><span class="p">;</span>
</span><span class='line'><span class="k">@import</span> <span class="s2">&quot;responsive&quot;</span><span class="p">;</span>
</span><span class='line'><span class="k">@import</span> <span class="s2">&quot;responsive-customized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>解說</h4>

<ul>
<li>bootstrap-config.scss 是用來修改「Bootstrap 預設的變數」</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scss'><span class='line'><span class="nv">$navbarHeight</span><span class="o">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
</span><span class='line'><span class="nv">$navbarBackgroundHighlight</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
</span><span class='line'><span class="nv">$navbarBackground</span><span class="o">:</span> <span class="mh">#F7F7F7</span><span class="p">;</span>
</span><span class='line'><span class="nv">$navbarSearchBackground</span><span class="o">:</span> <span class="mh">#EAECEF</span><span class="p">;</span>
</span><span class='line'><span class="nv">$navbarSearchBorder</span><span class="o">:</span> <span class="mh">#EAECEF</span><span class="p">;</span>
</span><span class='line'><span class="nv">$navbarSearchPlaceholderColor</span><span class="o">:</span> <span class="mh">#565E65</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>bootstrap 則是 Gemfile 裡面掛上的預設 bootstrap 包。（不修改）</p></li>
<li><p>bootstrap-customized.scss 則是無法透過修改變數的效果，通通放這裡用 override 的方式覆蓋。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scss'><span class='line'><span class="nc">.navbar</span> <span class="p">{</span>
</span><span class='line'>  <span class="nc">.navbar-inner</span> <span class="p">{</span>
</span><span class='line'>    <span class="na">background</span><span class="o">:</span> <span class="sx">url(/assets/bg_header.png)</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>responsive 是 bootstrap 用來作 responsive 的 css</li>
<li>responsive-customized 是你想要針對 bootstrap 的 resposnive 版本做的客製。</li>
</ul>


<h3>小結</h3>

<p>這樣你的 application 「理論上」就可以跟著 bootstrap 的小升級而升級，而不會被纏到這個纏那個&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cancan 實作角色權限設計的最佳實踐(3)]]></title>
    <link href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-3/"/>
    <updated>2012-07-30T23:03:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-3</id>
    <content type="html"><![CDATA[<h3>角色判斷 current_ability</h3>

<p>這是一段普通的 <code>ability.rb</code> 權限範例 code。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Ability</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">CanCan</span><span class="o">::</span><span class="no">Ability</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">blank?</span>
</span><span class='line'>      <span class="c1"># not logged in</span>
</span><span class='line'>      <span class="n">cannot</span> <span class="ss">:manage</span><span class="p">,</span> <span class="ss">:all</span>
</span><span class='line'>      <span class="n">basic_read_only</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">user</span><span class="o">.</span><span class="n">has_role?</span><span class="p">(</span><span class="ss">:admin</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># admin</span>
</span><span class='line'>      <span class="n">can</span> <span class="ss">:manage</span><span class="p">,</span> <span class="ss">:all</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">protected</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">basic_read_only</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:read</span><span class="p">,</span>    <span class="no">Topic</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:list</span><span class="p">,</span>    <span class="no">Topic</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:search</span><span class="p">,</span>  <span class="no">Topic</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般開發者最有疑問的是 <code>def initialize(user)</code> 這一段程式碼中的 user 到底是怎麼來的？怎麼會沒頭沒尾的天外飛來一個 user，然後對這個 user 進行角色判斷就可以動了？</p>

<p>這一段要追溯到&#8230;<a href="https://github.com/ryanb/cancan/blob/master/lib/cancan/controller_additions.rb">lib/controller_additions.rb</a> 中的這一段 current_ability。</p>

<p>cancan 裡面去判斷是否有權限的一直是 <code>current_abibilty</code>，而 <code>current_abibilty</code> initialize 的方式就是塞 current_user 進去。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">current_ability</span>
</span><span class='line'>  <span class="vi">@current_ability</span> <span class="o">||=</span> <span class="o">::</span><span class="no">Ability</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>所以 <code>initialize(user)</code> 裡的 <code>if user.blank?</code> 其實就等於 <code>if current_user.blank?</code>（若沒登入）。</p>

<p>這樣去解讀程式碼，看起來就好理解很多了…</p>

<h3>權限類別解說 :manage, :all, ..etc.</h3>

<p>cancan 裡面用了一堆自定義縮寫，如 <code>:manage</code>、<code>:read</code>、<code>:update</code>、<code>:all</code>，讓人不是很了解在做什麼。</p>

<ul>
<li>:manage: 是指這個 controller 內所有的 action</li>
<li>:read : 指 :index 和 :show</li>
<li>:update: 指 :edit 和 :update</li>
<li>:destroy: 指 :destroy</li>
<li>:create: 指 :new 和 :crate</li>
</ul>


<p>而 :all 是指所有 object (resource)</p>

<p>當然，不只是 CRUD 的 method 才可以被列上去，如果你有其他非 RESTful 的 method 如 :search，也是可以寫上去..，只是要一條一條列上去，有點麻煩就是了。</p>

<h4>組合技：alias_action</h4>

<p>cancan 還提供了組合技，要是嫌原先的 :update, :read 這種組合包不夠用。還可以用 <code>alias_action</code> 自己另外再組。例如把 :update 和 :destroy 組成 :modify。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>   <span class="n">alias_action</span> <span class="ss">:update</span><span class="p">,</span> <span class="ss">:destroy</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:modify</span>
</span><span class='line'>   <span class="n">can</span> <span class="ss">:modify</span><span class="p">,</span> <span class="no">Comment</span>
</span></code></pre></td></tr></table></div></figure>


<h4>組合技: 自訂 method</h4>

<p>要是你嫌每個角色都要一條一條把權限列上去，超麻煩。可以把一些共通的權限包成 method。用疊加 method 上去的方式列舉。比如把基礎權限都包成 <code>basic_read_only</code>、<code>account_manager_only</code>, etc…</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">basic_read_only</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:read</span><span class="p">,</span>    <span class="no">Topic</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:list</span><span class="p">,</span>    <span class="no">Topic</span>
</span><span class='line'>    <span class="n">can</span> <span class="ss">:search</span><span class="p">,</span>  <span class="no">Topic</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>針對物件狀態控管</h3>

<p>在 User story 中，使用者固然 <code>can :update, Topic</code>，但還是讓人覺得覺得哪裡有點怪怪的？</p>

<p>是的。使用者應該只能編輯和修改屬於自己的文章，<code>can :update, Topic</code> 只有說使用者可以「修改文章」啊（等於可以修改所有文章） XD</p>

<p>所以 <code>ability.rb</code> 就要這樣設計了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">can</span> <span class="ss">:update</span><span class="p">,</span> <span class="no">Topic</span> <span class="k">do</span> <span class="o">|</span><span class="n">topic</span><span class="o">|</span>
</span><span class='line'>    <span class="p">(</span><span class="n">topic</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">can</span> <span class="ss">:destroy</span><span class="p">,</span> <span class="no">Topic</span> <span class="k">do</span> <span class="o">|</span><span class="n">topic</span><span class="o">|</span>
</span><span class='line'>     <span class="p">(</span><span class="n">topic</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以玩的更加進階：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">can</span> <span class="ss">:publish</span><span class="p">,</span> <span class="no">Post</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class='line'>  <span class="p">(</span> <span class="n">post</span><span class="o">.</span><span class="n">draft?</span> <span class="o">||</span> <span class="n">post</span><span class="o">.</span><span class="n">submitted?</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">post</span><span class="o">.</span><span class="n">published?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>其他</h2>

<p>cancan 還有其他進階主題可以繼續探討，讀者可以自行研究：</p>

<ul>
<li><a href="https://github.com/ryanb/cancan/wiki/Nested-Resources">Nested Resources</a></li>
<li><a href="https://github.com/ryanb/cancan/wiki/Exception-Handling">Exception Handling</a></li>
<li><a href="https://github.com/ryanb/cancan/wiki/Ensure-Authorization">Ensure Authorization</a></li>
</ul>


<p>不過關於「難懂」和「難用」的部分，我想我應該講的差不多了…</p>

<h2>小結</h2>

<p>在寫這一系列文章時，我發現 cancan 的作者，其實把大部分的文件與範例，都寫在 lib/ 下的 RDOC 裡面了，光看 code comment 其實就可以瞭解大半流程。</p>

<p>不過我覺得 cancan 讓人覺得難讀的最大原因，可能還是官方缺乏一個 example <code>ability.rb</code>，對於被隱藏的自動完成部分也缺乏解釋，所以才造成大家覺得 cancan 是個難用的 magic library。事實上如果你開始搞懂 cancan 怎麼撰寫的話，它是可以幫你把網站的權限 code 處理的非常漂亮又易懂的。</p>

<p>這系列就寫到這邊，如果你對 cancan 還有什麼使用上的問題，歡迎到 <a href="http://www.meetup.com/Ruby-Taiwan-Group/">Rails Tuesday</a> 來找我討論。</p>

<h2>系列連結</h2>

<ul>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-1/">Cancan 實作角色權限設計的最佳實踐(1)</a></li>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-2/">Cancan 實作角色權限設計的最佳實踐(2)</a></li>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-3/">Cancan 實作角色權限設計的最佳實踐(3)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cancan 實作角色權限設計的最佳實踐(2)]]></title>
    <link href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-2/"/>
    <updated>2012-07-30T12:07:00+08:00</updated>
    <id>http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-2</id>
    <content type="html"><![CDATA[<h2>使用Cancan 的限制：RESTful controller （resource）</h2>

<p>一般新進開發者會被  cancan 這兩個 API 搞得七葷八素：<code>load_and_authorize_resource</code>、<code>authorize_resource</code>。</p>

<p>這是因為 cancan 並沒有明顯的在 README 上做出說明：<strong>cancan 在使用上是有架構的限制</strong>：</p>

<h4>* 必須為 RESTful resource</h4>

<p>（cancan 直接假設了你一定使用 RESTful，畢竟這年頭誰還在寫 non-RESTful …?）</p>

<h4>* resource 必須與 Controller 同名</h4>

<p>（@article 與 ArticlesController）</p>

<p>使用過 cancan 的人，大概都「猜到」規則好像是這樣？</p>

<p>其實不必猜，<a href="https://github.com/ryanb/cancan/blob/master/lib/cancan/controller_resource.rb">source code</a> 裡面就寫的很清楚。</p>

<h3>load_and_authorize_resource</h3>

<p>load_and_authorized_resource 做了兩件事：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>   <span class="k">def</span> <span class="nf">load_and_authorize_resource</span>
</span><span class='line'>      <span class="n">load_resource</span>
</span><span class='line'>      <span class="n">authorize_resource</span>
</span><span class='line'>    <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>load_resource</li>
<li>authorize_resource</li>
</ul>


<p>load_resource 作什麼呢？: loard_resource => load_resource_instance</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">load_resource_instance</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">!</span><span class="n">parent?</span> <span class="o">&amp;&amp;</span> <span class="n">new_actions</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="vi">@params</span><span class="o">[</span><span class="ss">:action</span><span class="o">].</span><span class="n">to_sym</span><span class="p">)</span>
</span><span class='line'>    <span class="n">build_resource</span>
</span><span class='line'>  <span class="k">elsif</span> <span class="n">id_param</span> <span class="o">||</span> <span class="vi">@options</span><span class="o">[</span><span class="ss">:singleton</span><span class="o">]</span>
</span><span class='line'>    <span class="n">find_resource</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>okay，這段的作用等於如果你在 Controller 裡面下了 load_resource，cancan 會<strong>自作聰明</strong>的幫你 <strong>自動</strong> 在每一個 action 塞一個 instance 下去</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lass</span> <span class="no">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">load_resource</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">new</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>    <span class="c1"># @article is already loaded</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果是 new 這個 action，效果會等於</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>   <span class="k">def</span> <span class="nf">new</span>
</span><span class='line'>     <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>   <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是 show 這個 action，效果會等於</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>   <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>     <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>   <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>有好處也有壞處，好處是…你不需要自己打一行 code，壞處就是不熟 cancan 的人，找不到 @article 在哪裡會驚慌失措…</p>

<p><code>load_resource</code> 還有一些其他進階用法，在 <a href="https://github.com/ryanb/cancan/blob/master/lib/cancan/controller_additions.rb">controller_additions.rb</a> 裡面有不少說明&#8230;</p>

<h3>authorize_resource</h3>

<p>authorize_resource 就是對 resource 判斷權限（根據 CanCan::Ability 裡的權限表）。</p>

<p>而這個 resource 必定是與同名的 instance。</p>

<p>如果是 ArticlesController 對應的必然是 @article。</p>

<p>但是你會想說這樣慘了？萬一我在 ArticlesController 裡面要用 @post 怎麼辦呢？</p>

<p>你可以在 controller 裡面指定 resource instance 的 name 要用什麼名字: <code>authorize_resource :post</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lass</span> <span class="no">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">authorize_resource</span> <span class="ss">:post</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">new</span>
</span><span class='line'>    <span class="vi">@post</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>    <span class="vi">@post</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Ability 裡面要這樣下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">can</span> <span class="ss">:read</span><span class="p">,</span> <span class="no">Post</span>
</span><span class='line'>  <span class="n">can</span> <span class="ss">:create</span><span class="p">,</span> <span class="no">Post</span>
</span><span class='line'>  <span class="n">can</span> <span class="ss">:update</span><span class="p">,</span> <span class="no">Post</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>resource 規則小結</h3>

<p>所以 cancan 裡面的 resource 第一個會去吃 controller 的名稱當成 resource name，如果是 <code>ArticlesController</code>，instance 就會是 <code>@article</code>，而在 ability 裡面就會是 <code>can :read, Article</code>。這是在假設你已經使用同名設計 resource &amp; controller 的情況下。</p>

<p>如果非同名。你可以做出指定：<code>authorize_resource :post</code>，雖然是 ArticlesController，但是這一組的 resource 名稱為 <code>post</code>，所以 instance 就會是 <code>@post</code>，而在 ability 裡面就會是 <code>can :read, Post</code>。</p>

<p>一般開發者常會誤會的是</p>

<ul>
<li>ability 會綁到 model，實際上不是</li>
<li>controller 名稱要與 @instance 名稱相同，實際上不一定</li>
<li>@instance 要與 model 同名，實際上不用</li>
<li>ability 吃的應該是 controller name，實際上不一定（吃的是 resource name，且可以被指定）。</li>
</ul>


<p>Cancan 吃的是 resource，而且自作聰明的假設了大家「應該」都同名，而且 README example 也是使用「同名」，才會造成了這麼多的誤解…</p>

<p>如果你有更多疑問，可以直接看 source code 裡面的 這一支<a href="https://github.com/ryanb/cancan/blob/master/lib/cancan/controller_resource.rb">controller_resource.rb</a>，相信會讓你對整個架構更加的清楚&#8230;</p>

<h2>小結</h2>

<p>這一節解釋了開發者認為最難懂的 <code>load_and_authorize_resource</code>、<code>authorize_resource</code>。下一節我們要來講 ability 要如何設計…</p>

<h2>系列連結</h2>

<ul>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-1/">Cancan 實作角色權限設計的最佳實踐(1)</a></li>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-2/">Cancan 實作角色權限設計的最佳實踐(2)</a></li>
<li><a href="http://blog.xdite.net/posts/2012/07/30/cancan-rule-engine-authorization-based-library-3/">Cancan 實作角色權限設計的最佳實踐(3)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
